---
title: C26117 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26117
helpviewer_keywords:
- C26117
ms.assetid: cc7ebc8d-9826-4cad-a4d5-2d3ad5896734
caps.latest.revision: 13
author: mikeblome
ms.author: mblome
manager: jillfra
ms.openlocfilehash: 9e01f60fbb59e304e4bcacb7f4b85ee110049266
ms.sourcegitcommit: 11337745c1aaef450fd33e150664656d45fe5bc5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/04/2019
ms.locfileid: "57323953"
---
# <a name="c26117"></a>C26117
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Ostrzeżenie C26117: Zwalnianie nie utrzymywanej blokady \<blokada > w funkcji \<func >.

Wymuszanie składniowo zakresie blokady *uzyskania* i blokadę przy użyciu *wersji* pary w programów C/C++ nie jest wykonywane przez język. Funkcja może powodować blokowanie efekt uboczny, wprowadzając dostrzegalnych modyfikacji stanu współbieżności. Na przykład funkcji otoku blokady zwiększa liczbę nabycia blokady lub liczbę blokad, dla danej blokady. Możesz dodawać adnotacje do funkcji, która ma efekt z blokadą nabycia lub zablokować wydania przy użyciu `_Acquires_lock_` lub `_Releases_lock_`, odpowiednio. Bez tych adnotacji funkcji oczekuje się, nie należy zmieniać dowolnej liczbie blokady po zwraca. Jeśli uzyskuje i wersje nie są równoważone, są traktowane jako *oddzielone*. Ostrzeżenie C26117 wystawiono, gdy funkcja, która nie ma zostać oznaczony za pomocą `_Releases_lock_` zwalnia blokadę, który go nie ma on, ponieważ funkcja musi być właścicielem blokady przed jej do wydania.

## <a name="example"></a>Przykład
Poniższy przykład generuje ostrzeżenie C26117, ponieważ funkcja `ReleaseUnheldLock` zwalnia blokadę, który nie musi przechowywać — stan `flag` jest niejednoznaczne — i nie ma żadnych adnotacji, określający, że należy.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
        EnterCriticalSection(&p->cs);
    // code ...
    LeaveCriticalSection(&p->cs);
}
```

## <a name="example"></a>Przykład
Poniższy kod naprawia problem, gwarantując, że wydane jest również blokada w tych samych warunkach.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
    {
        EnterCriticalSection(&p->cs);
        // code ...
        LeaveCriticalSection(&p->cs);
    }
}
```

## <a name="see-also"></a>Zobacz też
[C26115](../code-quality/c26115.md)
