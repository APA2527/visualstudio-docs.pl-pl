---
title: C26117 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26117
helpviewer_keywords:
- C26117
ms.assetid: cc7ebc8d-9826-4cad-a4d5-2d3ad5896734
caps.latest.revision: 13
author: mikeblome
ms.author: mblome
manager: jillfra
ms.openlocfilehash: b2af15df92faba17e979ea8cc468ec8eaf6a479b
ms.sourcegitcommit: 8b538eea125241e9d6d8b7297b72a66faa9a4a47
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/23/2019
ms.locfileid: "54764442"
---
# <a name="c26117"></a>C26117
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Ostrzeżenie C26117: Zwalnianie nie utrzymywanej blokady \<blokada > w funkcji \<func >.  
  
 Wymuszanie składniowo zakresie blokady *uzyskania* i blokadę przy użyciu *wersji* pary w programów C/C++ nie jest wykonywane przez język. Funkcja może powodować blokowanie efekt uboczny, wprowadzając dostrzegalnych modyfikacji stanu współbieżności. Na przykład funkcji otoku blokady zwiększa liczbę nabycia blokady lub liczbę blokad, dla danej blokady. Możesz dodawać adnotacje do funkcji, która ma efekt z blokadą nabycia lub zablokować wydania przy użyciu `_Acquires_lock_` lub `_Releases_lock_`, odpowiednio. Bez tych adnotacji funkcji oczekuje się, nie należy zmieniać dowolnej liczbie blokady po zwraca. Jeśli uzyskuje i wersje nie są równoważone, są traktowane jako *oddzielone*. Ostrzeżenie C26117 wystawiono, gdy funkcja, która nie ma zostać oznaczony za pomocą `_Releases_lock_` zwalnia blokadę, który go nie ma on, ponieważ funkcja musi być właścicielem blokady przed jej do wydania.  
  
## <a name="example"></a>Przykład  
 Poniższy przykład generuje ostrzeżenie C26117, ponieważ funkcja `ReleaseUnheldLock` zwalnia blokadę, który nie musi przechowywać — stan `flag` jest niejednoznaczne — i nie ma żadnych adnotacji, określający, że należy.  
  
```cpp  
  
typedef struct _DATA   
{  
    CRITICAL_SECTION cs;  
} DATA;  
  
int flag;  
  
void ReleaseUnheldLock(DATA* p)  
{  
    if (flag)  
        EnterCriticalSection(&p->cs);  
    // code ...  
    LeaveCriticalSection(&p->cs);  
}  
```  
  
## <a name="example"></a>Przykład  
 Poniższy kod naprawia problem, gwarantując, że wydane jest również blokada w tych samych warunkach.  
  
```cpp  
  
typedef struct _DATA   
{  
    CRITICAL_SECTION cs;  
} DATA;  
  
int flag;  
  
void ReleaseUnheldLock(DATA* p)  
{  
    if (flag)  
    {  
        EnterCriticalSection(&p->cs);  
        // code ...  
        LeaveCriticalSection(&p->cs);  
    }  
}  
```  
  
## <a name="see-also"></a>Zobacz też  
 [C26115](../code-quality/c26115.md)
