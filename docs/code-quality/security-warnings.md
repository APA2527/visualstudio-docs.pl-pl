---
title: Ostrzeżenia o zabezpieczeniach
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9b5a03c9cb7ae7c5a5c81bd452dbb04d8db4c09d
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/02/2020
ms.locfileid: "88052625"
---
# <a name="security-warnings"></a>Ostrzeżenia dotyczące zabezpieczeń

Ostrzeżenia o zabezpieczeniach obsługują bezpieczniejsze biblioteki i aplikacje. Ostrzeżenia te pomagają zapobiec usterkom w zabezpieczeniach w programie. Przyczynę wyłączenia któregokolwiek z tych ostrzeżeń należy wyraźnie oznaczyć w kodzie i poinformować o tym osobę odpowiedzialną za bezpieczeństwo w projekcie.

## <a name="in-this-section"></a>W tej sekcji

|Reguła|Opis|
|----------|-----------------|
|[CA2100: Sprawdź zapytania SQL pod kątem luk w zabezpieczeniach](../code-quality/ca2100.md)|Metoda ustawia właściwość System.Data.IDbCommand.CommandText przez użycie ciągu, który jest zbudowany z argumentem ciągu do metody. Zasada ta zakłada, że argument ciągu zawiera dane wejściowe użytkownika. Ciąg polecenia SQL zbudowany z danych wejściowych użytkownika jest narażony na ataki przez wstrzyknięcie kodu SQL.|
|[CA2102: Przechwytuj wyjątki bez atrybutu CLSCompliant w ogólnych procedurach obsługi](../code-quality/ca2102.md)|Element członkowski w zestawie, który nie jest oznaczony za pomocą atrybutu RuntimeCompatibilityAttribute lub jest oznaczony jako RuntimeCompatibility(WrapNonExceptionThrows = false), zawiera blok catch obsługujący wyjątek System.Exception i nie zawiera bezpośrednio następującego ogólnego bloku catch.|
|[CA2103: Przejrzyj zabezpieczenia imperatywne](../code-quality/ca2103.md)|Metoda używa imperatywnych zabezpieczeń i może konstruować uprawnienia za pomocą informacji o stanie lub wartości zwrotnych, które można zmienić, podczas gdy żądanie jest aktywne. Należy używać zabezpieczeń deklaracyjnych wszędzie, gdzie to możliwe.|
|[CA2104: Nie deklaruj modyfikowalnych typów referencyjnych tylko do odczytu](../code-quality/ca2104.md)|Typ widoczny z zewnątrz zawiera widoczne na zewnątrz pole tylko do odczytu, które jest typu referencji zmiennej. Typ zmienny to typ, którego dane wystąpienia mogą być modyfikowane.|
|[CA2105: Pola tablicy nie powinny być tylko do odczytu](../code-quality/ca2105.md)|Po zastosowaniu modyfikatora tylko do odczytu (ReadOnly w Visual Basic) do pola, które zawiera tablicę, pola nie można zmienić, aby odwoływać się do innej tablicy. Można jednak zmienić elementy tablicy przechowywane w polu tylko do odczytu.|
|[CA2106: Zabezpiecz asercje](../code-quality/ca2106.md)|Metoda potwierdza uprawnienia i żadne sprawdzenia zabezpieczeń nie są wykonywane na obiekcie wywołującym. Potwierdzanie uprawnienia zabezpieczeń bez sprawdzania zabezpieczeń może pozostawić zdatną do wykorzystania słabość zabezpieczeń w kodzie.|
|[CA2107: Przejrzyj przypadki użycia metod Deny i PermitOnly](../code-quality/ca2107.md)|Za pomocą metody PermitOnly i CodeAccessPermission. Deny akcje zabezpieczeń powinny być używane tylko przez te z zaawansowaną wiedzą o zabezpieczeniach platformy .NET. Kod, który używa tych akcji zabezpieczeń, należy poddać przeglądowi zabezpieczeń.|
|[CA2108: Przejrzyj zabezpieczenia deklaratywne dla typów wartości](../code-quality/ca2108.md)|Publiczny lub chroniony typ wartości jest zabezpieczony przez dostęp do danych lub zapotrzebowanie na łącza.|
|[CA2109: Przejrzyj widoczne procedury obsługi zdarzeń](../code-quality/ca2109.md)|Wykryto publiczną lub chronioną metodę obsługi zdarzeń. Metody obsługi zdarzeń nie powinny być udostępnione, chyba że jest to absolutnie konieczne.|
|[CA2111: Wskaźniki nie powinny być widoczne](../code-quality/ca2111.md)|Wskaźnik nie jest prywatny, wewnętrzny ani tylko do odczytu. Złośliwy kod może zmienić wartość wskaźnika, potencjalnie umożliwiając dostęp do dowolnego miejsca w pamięci lub powodując błędy aplikacji bądź systemu.|
|[CA2112: Zabezpieczone typy nie powinny ujawniać pól](../code-quality/ca2112.md)|Typ publiczny lub chroniony zawiera pola publiczne i jest zabezpieczony przez zapotrzebowania na łącza. Jeśli kod ma dostęp do wystąpienia typu zabezpieczonego przez żądanie łącza, kod nie musi spełniać zapotrzebowania na łącza, aby uzyskać dostęp do pól typu.|
|[CA2114: Zabezpieczenie metody powinno być nadzbiorem typu](../code-quality/ca2114.md)|Metoda nie powinna mieć zabezpieczeń deklaratywnych zarówno na poziomie metody, jak i na poziomie typu dla tej samej akcji.|
|[CA2115: Wywołaj funkcję GC.KeepAlive w przypadku korzystania z zasobów natywnych](../code-quality/ca2115.md)|Ta reguła wykrywa błędy, które mogą wystąpić, ponieważ kończy się działanie niezarządzanego zasobu, a wciąż jest on używany w kodzie niezarządzanym.|
|[CA2116: Metody z atrybutem APTCA powinny wywoływać tylko metody z atrybutem APTCA](../code-quality/ca2116.md)|Gdy atrybut APTCA (AllowPartiallyTrustedCallers) jest obecny w zestawie całkowicie zaufanym i wykonuje kod w innym zestawie, który nie zezwala na dostęp częściowo zaufanych wywołań, mogą zostać wykorzystane luki w zabezpieczeniach.|
|[CA2117: Typy z atrybutem APTCA powinny rozszerzać tylko typy podstawowe z atrybutem APTCA](../code-quality/ca2117.md)|Gdy atrybut APTCA (AllowPartiallyTrustedCallers) jest obecny w całkowicie zaufanym zestawie i typ w zestawie dziedziczy z typu, który nie zezwala na dostęp częściowo zaufanych wywołań, mogą zostać wykorzystane luki w zabezpieczeniach.|
|[CA2118: Przejrzyj przypadki użycia atrybutu SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute zmienia domyślne zachowanie systemu zabezpieczeń dla elementów członkowskich wykonujących kod niezarządzany, który używa wywołań międzyoperacyjnych COM lub platformy. Atrybut ten jest używany głównie w celu zwiększenia wydajności; jednak wzrost wydajności powoduje znaczące zagrożenia dla bezpieczeństwa.|
|[CA2119: Pieczętuj metody, które spełniają wymagania interfejsów prywatnych](../code-quality/ca2119.md)|Dziedziczony typ publiczny zapewnia implementację metody wewnętrznej (zaprzyjaźnionej w Visual Basic). Aby naprawić naruszenie tej zasady, należy zapobiegać zastąpieniu metody poza zestawem.|
|[CA2120: Zabezpiecz konstruktory serializacji](../code-quality/ca2120.md)|Typ ten ma konstruktor, który przyjmuje obiekt System.Runtime.Serialization.SerializationInfo i obiekt System.Runtime.Serialization.StreamingContext (podpis konstruktora serializacji). Ten konstruktor nie jest zabezpieczony przez sprawdzanie zabezpieczeń, ale jeden lub kilka regularnych konstruktorów typu jest zabezpieczonych.|
|[CA2121: Konstruktory statyczne powinny być prywatne](../code-quality/ca2121.md)|System wywołuje statyczny konstruktor przed utworzeniem pierwszego wystąpienia typu lub przed odwołaniem do któregokolwiek ze statycznych elementów członkowskich. Jeśli konstruktor statyczny nie jest prywatny, może być wywołany przez kod inny niż system. W zależności od operacji, które są wykonywane w konstruktorze, może to spowodować nieoczekiwane zachowanie.|
|[CA2122: Nie ujawniaj pośrednio metod żądaniami LinkDemand](../code-quality/ca2122.md)|Element członkowski publiczny lub chroniony ma zapotrzebowanie na łącza i jest wywoływany przez element członkowski, który nie sprawdza zabezpieczeń. Zapotrzebowanie na łącza sprawdza uprawnienia tylko bezpośredniego wywołującego.|
|[CA2123: Przesłonięcia żądań konsolidacji powinny być identyczne z podstawowymi](../code-quality/ca2123.md)|Ta reguła dopasowuje metodę do jej metody podstawowej, która jest interfejsem lub metodą wirtualną innego typu, a następnie porównuje zapotrzebowania na łącza na każdym z nich. Jeśli zasada ta jest naruszona, złośliwy wywołujący może pominąć zapotrzebowanie na łącza przez wywołanie niezabezpieczonej metody.|
|[CA2124: Opakuj podatne na przejęcie klauzule finally w zewnętrzny blok try](../code-quality/ca2124.md)|Metoda publiczna lub chroniona zawiera blok try/finally. Wygląda na to, że blok finally resetuje stan zabezpieczeń i sam nie jest ujęty w bloku finally.|
|[CA2126: Żądania LinkDemand dla typu wymagają żądań dziedziczenia](../code-quality/ca2126.md)|Niezamknięty typ publiczny jest chroniony za pomocą zapotrzebowania na łącza i ma metodę, którą można zastąpić. Ani typ, ani metoda nie są chronione za pomocą żądania dziedziczenia.|
|[CA2130: Stałe krytyczne pod względem zabezpieczeń powinny być przezroczyste](../code-quality/ca2130.md)|Wymuszanie przezroczystości nie jest wymuszane dla wartości stałych, ponieważ kompilatory wbudowują stałe wartości, tak aby nie było wymagane żadne wyszukiwanie w czasie wykonywania. Stałe pola powinny być przezroczyste dla zabezpieczeń, tak aby recenzenci kodu nie zakładali, że przezroczysty kod nie może uzyskać dostępu do stałej.|
|[CA2131: Typy krytyczne pod względem zabezpieczeń nie mogą brać udziału w określaniu równoważności typów](../code-quality/ca2131.md)|Typ uczestniczy w równoważności typu i albo sam typ, albo element członkowski lub pole typu, jest oznaczone atrybutem SecurityCriticalAttribute. Ta reguła jest uruchamiana na wszystkich typach krytycznych lub typach zawierających metody krytyczne lub pola, które uczestniczą w równoważeniu typu. Gdy CLR wykryje taki typ, uniemożliwia jego załadowanie, wywołując w czasie wykonywania wyjątek TypeLoadException. Zazwyczaj ta reguła uruchamiana jest tylko wtedy, gdy użytkownicy implementują równoważenie typu ręcznie, zamiast wykonać je, opierając się na otokach tlbimp i kompilatorach.|
|[CA2132: Konstruktory domyślne muszą być co najmniej tak krytyczne jak konstruktory domyślne typu podstawowego](../code-quality/ca2132.md)|Typy i elementy członkowskie, które mają atrybut SecurityCriticalAttribute, nie mogą być używane przez kod aplikacji Silverlight. Krytyczne dla bezpieczeństwa typy i składowe mogą być używane tylko przez zaufany kod w środowisku .NET Framework dla biblioteki klas Silverlight. Ze względu na to, że publiczna lub chroniona konstrukcja w klasie pochodnej musi mieć taką samą lub większą przejrzystość jak jej klasa bazowa, klasy w aplikacji nie mogą pochodzić z klasy oznaczonej jako SecurityCritical.|
|[CA2133: Delegaci muszą być powiązani z metodami ze spójną przezroczystością](../code-quality/ca2133.md)|To ostrzeżenie uruchamiane jest na metodzie wiążącej obiekt delegowany, oznaczony za pomocą atrybutu SecurityCriticalAttribute, do metody, która jest przezroczysta lub oznaczona za pomocą atrybutu SecuritySafeCriticalAttribute. Ostrzeżenie jest także uruchamiane na metodzie wiążącej obiekt delegowany, który jest przezroczysty lub bezpieczny-krytyczny dla metody krytycznej.|
|[CA2134: Metody muszą zachowywać spójną przezroczystość podczas nadpisywania metod bazowych](../code-quality/ca2134.md)|Ta reguła jest uruchamiana, gdy metoda oznaczona za pomocą atrybutu SecurityCriticalAttribute zastępuje metodę, która jest przezroczysta lub oznaczona za pomocą atrybutu SecuritySafeCriticalAttribute. Reguła ta jest również uruchamiana, gdy metoda przezroczysta lub oznaczona atrybutem SecuritySafeCriticalAttribute zastępuje metodę oznaczoną atrybutem SecurityCriticalAttribute. Reguła jest stosowana podczas zastępowania metody wirtualnej lub implementującej interfejs.|
|[CA2135: Zestawy poziomu 2 nie powinny zawierać żądań LinkDemand](../code-quality/ca2135.md)|LinkDemands są przestarzałe w zestawie reguł zabezpieczeń poziomu 2. Zamiast używania LinkDemands do wymuszenia zabezpieczeń w czasie kompilacji just in time (JIT), należy oznaczyć metody, typy i pola za pomocą atrybutu SecurityCriticalAttribute.|
|[CA2136: Adnotacje przezroczystości składowych nie powinny powodować konfliktu](../code-quality/ca2136.md)|Atrybuty przezroczystości są stosowane od elementów kodu o większym zakresie do elementów o mniejszym zakresie. Atrybuty przezroczystości elementów kodu z większym zakresem mają pierwszeństwo przed atrybutami przejrzystości elementów kodu, które są zawarte w pierwszym elemencie. Na przykład klasa, która jest oznaczona za pomocą atrybutu SecurityCriticalAttribute, nie może zawierać metody oznaczonej atrybutem SecuritySafeCriticalAttribute.|
|[CA2137: Metody przezroczyste muszą zawierać tylko weryfikowalny język pośredni](../code-quality/ca2137.md)|Metoda zawiera nieweryfikowalny kod lub zwraca typ przez odwołanie. Ta reguła jest uruchamiana podczas próby wykonywania przez kod przezroczysty pod względem zabezpieczeń nieweryfikowalnego MSIL (Microsoft Intermediate Language). Jednak reguła nie zawiera pełnej weryfikacji IL i używa heurystyki do wykrywania większości naruszeń weryfikacji MSIL.|
|[CA2138: Metody przezroczyste nie mogą wywoływać metod z atrybutem SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Metoda przezroczysta pod względem bezpieczeństwa wywołuje metodę, która jest oznaczona za pomocą atrybutu SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Metody przezroczyste nie mogą używać atrybutu HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Ta zasada jest uruchamiana dla dowolnej metody, która jest przejrzysta i próbuje obsłużyć wyjątek powodujący uszkodzenie procesu przy użyciu atrybutu HandleProcessCorruptedStateExceptionsAttribute. Wyjątek powodujący uszkodzenie procesu to klasyfikacja wyjątków CLR w wersji 4,0 wyjątków, takich jak <xref:System.AccessViolationException> . Atrybut HandleProcessCorruptedStateExceptionsAttribute może być używany tylko przez metody krytyczne pod względem bezpieczeństwa i będzie ignorowany, jeśli zostanie zastosowany do metody przezroczystej.|
|[CA2140: Kod przezroczysty nie może przywoływać elementów krytycznych pod względem zabezpieczeń](../code-quality/ca2140.md)|Metody, które są oznaczone przez atrybut SecurityTransparentAttribute, wywołują niepubliczne elementy członkowskie, które są oznaczone jako SecurityCritical. Ta reguła analizuje wszystkie metody i typy w zestawie, który jest mieszany przezroczysty i krytyczny, i flaguje wszelkie wywołania z przezroczystego kodu do niepublicznego niepublicznego kodu, który nie jest oznaczony jako SecurityTreatAsSafe.|
|[Metody CA2141:Transparent nie mogą spełniać LinkDemands](../code-quality/ca2141.md)|Metoda przezroczysta pod względem zabezpieczeń wywołuje metodę z zestawu, która nie jest oznaczona atrybutem AllowPartiallyTrustedCallersAttribute (APTCA), lub metoda przezroczysta pod względem zabezpieczeń spełnia żądanie LinkDemand dla typu lub metody.|
|[CA2142: Kod przezroczysty nie powinien być chroniony za pomocą żądań LinkDemand](../code-quality/ca2142.md)|Ta reguła jest uruchamiana na przezroczystych metodach wymagających żądania LinkDemands, aby uzyskać do nich dostęp. Przezroczysty kod zabezpieczeń nie powinien być odpowiedzialny za weryfikację zabezpieczeń operacji, a zatem nie powinien wymagać uprawnień.|
|[CA2143: Metody przezroczyste nie powinny używać żądań zabezpieczeń](../code-quality/ca2143.md)|Przezroczysty kod zabezpieczeń nie powinien być odpowiedzialny za weryfikację zabezpieczeń operacji, a zatem nie powinien wymagać uprawnień. Przejrzysty pod względem bezpieczeństwa kod powinien używać pełnych żądań do podejmowania decyzji związanych z zabezpieczeniami, a kod krytyczny pod względem zabezpieczeń nie powinien opierać się na kodzie przezroczystym do wykonywania pełnego żądania.|
|[CA2144: Kod przezroczysty nie powinien ładować zestawów z tablic bajtowych](../code-quality/ca2144.md)|Przegląd zabezpieczeń dla kodu przezroczystego nie jest tak dokładny jak kodu krytycznego pod względem bezpieczeństwa, ponieważ przezroczysty kod nie może wykonywać czynności wrażliwych pod względem bezpieczeństwa. Zestawy, ładowane z tablicy bajtowej, mogą nie być niezauważone w przezroczystym kodzie, a ta tablica bajtów może zawierać krytyczny albo, co ważniejsze, krytyczny dla bezpieczeństwa kod, który powinien być poddany inspekcji.|
|[CA2145: Metody przezroczyste nie powinny być dekorowane za pomocą atrybutu SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Metody, które są oznaczone przez atrybut SuppressUnmanagedCodeSecurityAttribute, mają niejawne żądanie LinkDemand umieszczone na dowolnej metodzie, która je wywołuje. Ten element LinkDemand wymaga, aby kod wywołujący był krytyczny dla bezpieczeństwa. Oznaczanie metody, która używa zabezpieczenia SuppressUnmanagedCodeSecurity poprzez użycie atrybutu SecurityCriticalAttribute, sprawia, że wymóg ten jest bardziej oczywisty dla obiektów wywołujących metodę.|
|[CA2146: Typy muszą być co najmniej tak krytyczne jak ich typy i interfejsy podstawowe](../code-quality/ca2146.md)|Ta reguła jest uruchamiana, gdy typ pochodny ma atrybut przezroczystości pod względem zabezpieczeń, który nie jest tak krytyczny, jak jego typ podstawowy lub zaimplementowany interfejs. Tylko typy krytyczne pod względem zabezpieczeń mogą pochodzić od podstawowych typów krytycznych lub implementować interfejsy krytyczne, a tylko typy krytyczne lub krytyczne dla bezpieczeństwa mogą pochodzić od podstawowych typów krytycznych dla bezpieczeństwa lub implementować interfejsy krytyczne dla bezpieczeństwa.|
|[CA2147: Metody przezroczyste nie mogą używać asercji zabezpieczeń](../code-quality/ca2147.md)|Reguła ta analizuje wszystkie metody i typy w zestawie, który jest w 100% przezroczysty lub mieszany przezroczysto-krytyczny i zaznacza deklaratywne lub imperatywne użycie potwierdzenia.|
|[CA2149: Metody przezroczyste nie mogą wywoływać kodu natywnego](../code-quality/ca2149.md)|Ta zasada jest uruchamiana dla dowolnej przezroczystej metody, która wywołuje bezpośrednio do kodu natywnego, na przykład za pomocą P/Invoke. Naruszenie tej zasady prowadzi do wyjątku MethodAccessException w poziomie 2 modelu przezroczystości i pełnego żądania dla UnmanagedCode w modelu przezroczystości poziomu 1.|
|[CA2151: Pola typu krytycznego powinny być krytyczne pod względem zabezpieczeń](../code-quality/ca2151.md)|Aby używać typów krytycznych pod względem zabezpieczeń, kod odwołujący się do typu musi być albo krytyczny pod względem zabezpieczeń, albo bezpieczny-krytyczny pod względem zabezpieczeń. Ta zasada obowiązuje nawet w przypadku odwołania pośredniego. Dlatego pole mające zabezpieczenia przezroczyste lub pole bezpieczne-krytyczne pod względem zabezpieczeń jest mylące, ponieważ przezroczysty kod nadal nie będzie mógł uzyskać dostępu do pola.|
|[CA2153: Unikaj obsługiwania wyjątków stanu uszkodzenia](../code-quality/ca2153.md)|[Wyjątki uszkodzonych Stanów (rozszerzenie klienta)](https://msdn.microsoft.com/magazine/dd419661.aspx) wskazują, że uszkodzenie pamięci istnieje w procesie. Ich przechwycenie zamiast zezwalania na awarię procesu może prowadzić do luk w zabezpieczeniach, jeśli osoba atakująca może wykorzystać lukę w uszkodzonym regionie pamięci.|
|[CA2300: Nie używaj niezabezpieczonego deserializatora BinaryFormatter](../code-quality/ca2300.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2301: Nie wywołuj metody BinaryFormatter.Deserialize bez uprzedniego ustawienia właściwości BinaryFormatter.Binder](../code-quality/ca2301.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2302: Upewnij się, że właściwość BinaryFormatter.Binder jest ustawiona przed wywołaniem metody BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2305: Nie używaj niezabezpieczonego deserializatora LosFormatter](../code-quality/ca2305.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2310: Nie używaj niezabezpieczonego deserializatora NetDataContractSerializer](../code-quality/ca2310.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2311: Nie wykonuj deserializacji bez uprzedniego ustawienia właściwości NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2312: Upewnij się, że właściwość NetDataContractSerializer.Binder jest ustawiona przed deserializacją](../code-quality/ca2312.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2315: Nie używaj niezabezpieczonego deserializatora ObjectStateFormatter](../code-quality/ca2315.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2321: Nie wykonuj deserializacji za pomocą obiektu JavaScriptSerializer zainicjowanego przy użyciu parametru SimpleTypeResolver](../code-quality/ca2321.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2322: Upewnij się, że obiekt JavaScriptSerializer nie został zainicjowany przy użyciu parametru SimpleTypeResolver przed deserializacją](../code-quality/ca2322.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2326: Nie używaj wartości TypeNameHandling innych niż None](../code-quality/ca2326.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2327: Nie używaj niezabezpieczonych ustawień JsonSerializerSettings](../code-quality/ca2327.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2328: Upewnij się, że ustawienia JsonSerializerSettings zostały zabezpieczone](../code-quality/ca2328.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2329: Nie deserializuj przy użyciu rozwiązania JsonSerializer za pomocą niezabezpieczonej konfiguracji](../code-quality/ca2329.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2330: Upewnij się, że podczas deserializacji rozwiązania JsonSerializer ma bezpieczną konfigurację](../code-quality/ca2330.md)|Niezabezpieczone deserializatory są narażone na deserializacja niezaufanych danych. Osoba atakująca może zmodyfikować serializowane dane w celu uwzględnienia nieoczekiwanych typów, aby wstrzyknąć obiekty ze złośliwymi efektami ubocznymi.|
|[CA2350: Upewnij się, że dane wejściowe elementu DataTable.ReadXml () są zaufane](ca2350.md)|Podczas deserializacji <xref:System.Data.DataTable> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2351: Upewnij się, że dane wejściowe elementu DataSet.ReadXml () są zaufane](ca2351.md)|Podczas deserializacji <xref:System.Data.DataSet> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2352: Niebezpieczny element DataSet lub DataTable w typie możliwym do serializacji może być podatny na ataki polegające na zdalnym wykonaniu kodu](ca2352.md)|Klasa lub struktura oznaczona przy użyciu <xref:System.SerializableAttribute> zawiera <xref:System.Data.DataSet> pole lub <xref:System.Data.DataTable> Właściwość i nie ma <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Niebezpieczny element DataSet lub DataTable w typie możliwym do serializacji](ca2353.md)|Klasa lub struktura oznaczona przy użyciu atrybutu serializacji XML lub atrybutu kontraktu danych zawiera <xref:System.Data.DataSet> <xref:System.Data.DataTable> pole or lub właściwość.|
|[CA2354: Niebezpieczny element DataSet lub DataTable w deserializowanym wykresie obiektu może być podatny na atak polegający na zdalnym wykonaniu kodu](ca2354.md)|Deserializacja z <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializowaną, a wykres obiektu typu rzutowego może zawierać <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2355: Niebezpieczny element DataSet lub DataTable w deserializowanym wykresie obiektu](ca2355.md)|Deserializacja, gdy wykres obiektu rzutowanego lub określonego typu może zawierać <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2356: niebezpieczny zestaw danych lub DataTable w grafie obiektów deserializowanych sieci Web](ca2356.md)|Metoda z <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> lub <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> ma parametr, który może odwoływać się do <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> .|
|[CA2361: Upewnij się, że automatycznie wygenerowana klasa zawierająca element DataSet.ReadXml() nie jest używana z niezaufanymi danymi](ca2361.md)|Podczas deserializacji <xref:System.Data.DataSet> z niezaufanymi danymi wejściowymi, osoba atakująca może przedrzemieślniczić złośliwe dane wejściowe w celu przeprowadzenia ataku typu "odmowa usługi". Mogą wystąpić nieznane luki w zabezpieczeniach dotyczące zdalnego wykonywania kodu.|
|[CA2362: Niebezpieczny element DataSet lub DataTable w automatycznie wygenerowanym typie, który można serializować, może być narażony na ataki polegające na zdalnym wykonaniu kodu](ca2362.md)|Podczas deserializacji niezaufanych danych wejściowych przy użyciu programu <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i deserializowany obiekt Graph zawiera <xref:System.Data.DataSet> lub <xref:System.Data.DataTable> , osoba atakująca może nawiązać złośliwy ładunek w celu wykonania ataku zdalnego wykonywania kodu.|
|[CA3001: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu SQL](../code-quality/ca3001.md)|Podczas pracy z niezaufanymi poleceniami wejściowymi i SQL należy zastanowić się nad atakami polegającymi na iniekcji SQL. Atak wykorzystujący wstrzyknięcie kodu SQL może wykonywać złośliwe polecenia SQL, narażając zabezpieczenia i integralność aplikacji.|
|[CA3002: Przegląd kodu pod kątem luk umożliwiających działanie skryptów między witrynami](../code-quality/ca3002.md)|Podczas pracy z niezaufanymi danymi wejściowymi z żądań sieci Web należy zastanowić się, jak ataki między środowiskami (XSS). Atak typu "XSS" powoduje dodanie niezaufanych danych wejściowych do nieprzetworzonych danych wyjściowych HTML, co umożliwia osobie atakującej wykonywanie złośliwych skryptów lub złośliwie modyfikowanie zawartości na stronie sieci Web.|
|[CA3003: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie ścieżki pliku](../code-quality/ca3003.md)|Podczas pracy z niezaufanymi danymi wejściowymi z żądań sieci Web należy zastanowić się nad użyciem danych wejściowych sterowanych przez użytkownika podczas określania ścieżek do plików.|
|[CA3004: Przegląd kodu pod kątem luk umożliwiających ujawnienie informacji](../code-quality/ca3004.md)|Odłączanie informacji o wyjątkach daje osobom atakującym wgląd w wewnętrzne dane aplikacji, co może pomóc atakującym znaleźć inne luki w zabezpieczeniach.|
|[CA3006: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie polecenia procesu](../code-quality/ca3006.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad atakami polegającymi na iniekcji poleceń. Atak polegający na iniekcji poleceń może wykonywać złośliwe polecenia w podstawowym systemie operacyjnym, narażając zabezpieczenia i integralność serwera.|
|[CA3007: Przegląd kodu pod kątem luk umożliwiających otwarcie przekierowania](../code-quality/ca3007.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze luki w zabezpieczeniach dotyczące otwartych przekierowań. Osoba atakująca może wykorzystać lukę w zabezpieczeniach Open Redirect, aby użyć witryny sieci Web w celu uzyskania oryginalnego adresu URL, ale przekierować niepodejrzanego gościa do phishingu lub innej złośliwej strony sieci Web.|
|[CA3008: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia XPath](../code-quality/ca3008.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad atakami z użyciem kodu XPath. Konstruowanie zapytań XPath przy użyciu niezaufanych danych wejściowych może pozwolić osobie atakującej na złośliwe manipulowanie kwerendą w celu zwrócenia niezamierzonego wyniku i może ujawnić zawartość pliku XML z kwerendą.|
|[CA3009: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XML](../code-quality/ca3009.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki kodu XML.|
|[CA3010: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XAML](../code-quality/ca3010.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki kodu XAML. XAML jest językiem znaczników, który bezpośrednio reprezentuje Tworzenie wystąpienia obiektu i wykonywanie. Oznacza to, że elementy utworzone w języku XAML mogą korzystać z zasobów systemowych (np. dostępu do sieci i we/wy systemu plików).|
|[CA3011: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie biblioteki DLL](../code-quality/ca3011.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy zastanowić się nad ładowaniem niezaufanego kodu. Jeśli aplikacja sieci Web ładuje niezaufany kod, osoba atakująca może dodawać złośliwe biblioteki DLL do procesu i wykonywać złośliwe kod.|
|[CA3012: Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia regularnego](../code-quality/ca3012.md)|Podczas pracy z niezaufanymi danymi wejściowymi należy mieć na uwadze ataki z iniekcją wyrażeń regularnych. Osoba atakująca może użyć iniekcji wyrażenia regularnego w celu złośliwego zmodyfikowania wyrażeń regularnych, aby wyrażenie regularne pasowało do nieoczekiwanych wyników, lub aby wyrażenie regularne zużywać nadmierny procesor w wyniku ataku typu "odmowa usługi".|
|[CA3061: Nie dodawaj schematu według adresu URL](../code-quality/ca3061.md)|Nie używaj niebezpiecznego przeciążenia metody Add, ponieważ może to spowodować niebezpieczne odwołania zewnętrzne.|
|[CA3075: Niezabezpieczone przetwarzanie definicji DTD](../code-quality/ca3075.md)|Jeśli używasz niezabezpieczonych wystąpień DTDProcessing lub referencyjnych źródeł zewnętrznych, Analizator może zaakceptować niezaufane dane wejściowe i ujawnić poufne informacje osobom atakującym.|
|[CA3076: Niezabezpieczone wykonywanie skryptu XSLT](../code-quality/ca3076.md)|W przypadku wykonywania Extensible Stylesheet Language transformacji (XSLT) w aplikacjach .NET w niezabezpieczony sposób procesor może rozpoznać niezaufane odwołania do identyfikatorów URI, które mogą ujawnić poufne informacje osobom atakującym, prowadząc do odmowy usługi i ataków między lokacjami.|
|[CA3077: Niezabezpieczone przetwarzanie w elemencie Design interfejsu API, dokumencie XML i czytniku tekstu dla kodu XML](../code-quality/ca3077.md)|Podczas projektowania interfejsu API pochodnego od XmlDocument i XMLTextReader należy mieć na uwadze, że DtdProcessing. Używanie niezabezpieczonych wystąpień DTDProcessing w przypadku odwoływania się do lub rozpoznawania zewnętrznych źródeł jednostek lub ustawiania niezabezpieczonych wartości w kodzie XML może prowadzić do ujawnienia informacji.|
|[CA3147: Oznaczanie procedur obsługi zleceń za pomocą tokenu ValidateAntiForgeryToken](../code-quality/ca3147.md)|Podczas projektowania kontrolera MVC ASP.NET należy zastanowić się, że zachodzą przypadki fałszerstwa żądań między witrynami. Atakujący sfałszowanie żądań między lokacjami może wysyłać złośliwych żądań od uwierzytelnionego użytkownika do kontrolera MVC ASP.NET.|
|[Deklaracje P/Invoke CA5122 deklaracje nie powinny być bezpieczne krytyczne](../code-quality/ca5122.md)|Metody są oznaczone jako SecuritySafeCritical, gdy wykonują operacje zależne od zabezpieczeń, ale mogą być również bezpiecznie używane przez kod przezroczystości. Kod przezroczystości może nigdy bezpośrednio nie wywołać kodu natywnego za pośrednictwem metody P/Invoke. Dlatego oznakowanie metody P/Invoke jako bezpiecznej-krytycznej pod względem zabezpieczeń nie umożliwi jej wywołania kodu przezroczystości i jest mylące dla analizy zabezpieczeń.|
|[CA5359: Nie wyłączaj walidacji certyfikatów](../code-quality/ca5359.md)|Certyfikat może pomóc uwierzytelnić tożsamość serwera programu. Klienci powinni sprawdzić poprawność certyfikatu serwera, aby upewnić się, że żądania są wysyłane do zamierzonego serwera. Jeśli ServerCertificateValidationCallback zawsze zwróci `true` , każdy certyfikat przejdzie pomyślnie weryfikację.|
|[CA5360: Nie wywołuj niebezpiecznych metod w deserializacji](../code-quality/ca5360.md)|Niezabezpieczona deserializacja jest luką w zabezpieczeniach, która występuje, gdy niezaufane dane są używane do nadużycia logiki aplikacji, wynoszą atak typu "odmowa usługi" (DoS), a nawet wykonują dowolny kod podczas deserializacji. Często Złośliwi użytkownicy mogą nadużyć tych funkcji deserializacji, gdy aplikacja deserializacji dane niezaufane, które są pod kontrolą. W celu wywołaj metody niebezpieczne w procesie deserializacji. Pomyślne niezabezpieczone ataki deserializacji mogą pozwolić atakującemu na przeprowadzanie ataków, takich jak ataki systemu DoS, obejścia uwierzytelniania i zdalne wykonywanie kodu.|
|[CA5361: Nie wyłączaj użycia silnej kryptografii w pakiecie SChannel](../code-quality/ca5361.md)|Ustawienie `Switch.System.Net.DontEnableSchUseStrongCrypto` `true` obniżania poziomu kryptografii używanej w połączeniach wychodzących Transport Layer Security (TLS). Słabsze Kryptografia może naruszać poufność komunikacji między aplikacją a serwerem, ułatwiając atakującym eavesdrop poufnych danych.|
|[CA5362: Potencjalny cykl odwołań w grafie obiektu deserializowanego](../code-quality/ca5362.md)|W przypadku deserializacji niezaufanych danych, każdy kod przetwarzania deserializowanego grafu obiektów musi obsługiwać cykle odwołań bez przechodzenia do nieskończonych pętli. Obejmuje to zarówno kod, który jest częścią wywołania zwrotnego deserializacji i kod, który przetwarza Graf obiektu po zakończeniu deserializacji. W przeciwnym razie atakujący może przeprowadzić atak typu "odmowa usługi" ze złośliwymi danymi zawierającymi cykl referencyjny.|
|[CA5363: Nie wyłączaj weryfikacji żądań](../code-quality/ca5363.md)|Sprawdzanie poprawności żądań jest funkcją w ASP.NET, która sprawdza żądania HTTP i określa, czy zawierają potencjalnie niebezpieczną zawartość, która może prowadzić do ataków iniekcji, w tym skryptów między lokacjami.|
|[CA5364: Nie używaj przestarzałych protokołów zabezpieczeń](../code-quality/ca5364.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Starsze wersje protokołu TLS są mniej bezpieczne niż TLS 1,2 i TLS 1,3 i coraz bardziej mogą mieć nowe luki w zabezpieczeniach. Unikaj stosowania starszych wersji protokołów, aby zminimalizować ryzyko.|
|[CA5365: Nie wyłączaj sprawdzania nagłówka HTTP](../code-quality/ca5365.md)|Sprawdzanie nagłówka HTTP włącza kodowanie znaku powrotu karetki i znaków nowego wiersza, \r i \n, które znajdują się w nagłówkach odpowiedzi. To kodowanie może ułatwić uniknięcie ataków wykorzystujących niezaufane dane zawarte w nagłówku przez program.|
|[CA5366: Użyj czytnika XmlReader na potrzeby pliku XML odczytu zestawu danych](../code-quality/ca5366.md)|Korzystanie z programu <xref:System.Data.DataSet> do odczytywania danych XML z niezaufanymi danymi może ładować niebezpieczne odwołania zewnętrzne, które powinny być ograniczone przy użyciu programu <xref:System.Xml.XmlReader> z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem DTD.|
|[CA5367: Nie serializuj typów z polami wskaźników](../code-quality/ca5367.md)|Ta reguła sprawdza, czy istnieje Klasa możliwa do serializacji z polem wskaźnika lub właściwością. Elementy członkowskie, które nie mogą być serializowane, mogą być wskaźnikami, takimi jak statyczne elementy członkowskie lub pola oznaczone przy użyciu <xref:System.NonSerializedAttribute> .|
|[CA5368: Ustaw właściwość ViewStateUserKey dla klas pochodzących od klasy Page](../code-quality/ca5368.md)|Ustawienie <xref:System.Web.UI.Page.ViewStateUserKey> właściwości może pomóc w zapobieganiu atakom w aplikacji przez umożliwienie przypisania identyfikatora do zmiennej stanu widoku dla poszczególnych użytkowników, tak aby atakujący nie mogli użyć zmiennej do wygenerowania ataku. W przeciwnym razie zostaną wystąpiły luki w zabezpieczeniach związane z fałszerstwem żądań między lokacjami.|
|[CA5369: Używaj elementu XmlReader do deserializacji](../code-quality/ca5369.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych, które powinny być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem schematu DTD i XML.|
|[CA5370: Używaj elementu XmlReader do weryfikacji czytelnika](../code-quality/ca5370.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych. To niebezpieczne ładowanie może być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem schematu DTD i XML.|
|[CA5371: Używaj elementu XmlReader do odczytywania schematu](../code-quality/ca5371.md)|Przetwarzanie niezaufanych schematów DTD i XML może umożliwić ładowanie niebezpiecznych odwołań zewnętrznych. Używanie elementu XmlReader z bezpiecznym programem rozpoznawania nazw lub z wyłączonym przetwarzaniem schematu DTD i XML jest ograniczone.|
|[CA5372: Używaj elementu XmlReader dla elementu XPathDocument](../code-quality/ca5372.md)|Przetwarzanie kodu XML z niezaufanych danych może ładować niebezpieczne odwołania zewnętrzne, które mogą być ograniczone przy użyciu elementu XmlReader z bezpiecznym mechanizmem rozwiązywania konfliktów lub z wyłączonym przetwarzaniem DTD.|
|[CA5373: Nie używaj przestarzałej funkcji wyprowadzania klucza](../code-quality/ca5373.md)|Ta zasada wykrywa wywoływanie metod wyprowadzania słabych kluczy <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> i `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> użyto słabego algorytmu PBKDF1.|
|[CA5374: Nie używaj klasy XslTransform](../code-quality/ca5374.md)|Ta reguła sprawdza, czy <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> jest tworzone wystąpienie w kodzie. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> jest już przestarzałe i nie należy go używać.|
|[CA5375: Nie używaj sygnatury dostępu współdzielonego konta](../code-quality/ca5375.md)|Sygnatura dostępu współdzielonego konta może delegować dostęp do operacji odczytu, zapisu i usuwania dla kontenerów obiektów blob, tabel, kolejek i udziałów plików, które nie są dozwolone przy użyciu sygnatury dostępu współdzielonego usługi. Nie obsługuje jednak zasad na poziomie kontenera i zapewnia mniejszą elastyczność i kontrolę nad udzielonymi uprawnieniami. Po otrzymaniu złośliwych użytkowników Twoje konto magazynu zostanie łatwo naruszone.|
|[CA5376: Użyj właściwości HttpsOnly elementu SharedAccessProtocol](../code-quality/ca5376.md)|Sygnatury dostępu współdzielonego to dane poufne, których nie można transportować w postaci zwykłego tekstu na HTTP|
|[CA5377: Użyj zasad dostępu na poziomie kontenera](../code-quality/ca5377.md)|Zasady dostępu na poziomie kontenera można zmodyfikować lub odwołać w dowolnym momencie. Zapewnia większą elastyczność i kontrolę nad udzielonymi uprawnieniami.|
|[CA5378: Nie wyłączaj protokołów ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Ustawienie `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` `true` ograniczające połączenia Transport Layer Security (TLS) środowiska Windows Communication Framework z użyciem protokołu TLS 1,0. Ta wersja protokołu TLS zostanie wycofana.|
|[CA5379: Nie używaj słabego algorytmu funkcji wyprowadzania kluczy](../code-quality/ca5379.md)|<xref:System.Security.Cryptography.Rfc2898DeriveBytes>Klasa domyślnie używa <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorytmu. Należy określić algorytm wyznaczania wartości skrótu, który ma być używany w niektórych przeciążeniach konstruktora z <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> lub wyższym. Uwaga, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> Właściwość ma tylko `get` metodę dostępu i nie ma `overriden` modyfikatora.|
|[CA5380: Nie dodawaj certyfikatów do magazynu głównego](../code-quality/ca5380.md)|Ta reguła wykrywa kod, który dodaje certyfikat do magazynu certyfikatów zaufanych głównych urzędów certyfikacji. Domyślnie magazyn certyfikatów zaufanych głównych urzędów certyfikacji jest skonfigurowany przy użyciu zestawu publicznych urzędów certyfikacji, które spełniają wymagania programu certyfikatów głównych firmy Microsoft.|
|[CA5381: Upewnij się, że certyfikaty nie są dodawane do magazynu głównego](../code-quality/ca5381.md)|Ta reguła wykrywa kod, który potencjalnie dodaje certyfikat do magazynu certyfikatów zaufanych głównych urzędów certyfikacji. Domyślnie magazyn certyfikatów zaufanych głównych urzędów certyfikacji jest skonfigurowany przy użyciu zestawu publicznych urzędów certyfikacji (CA), które spełniają wymagania programu certyfikatów głównych firmy Microsoft.|
|[CA5382: Użyj bezpiecznych plików cookie na platformie ASP.NET Core](../code-quality/ca5382.md)|Aplikacje dostępne za pośrednictwem protokołu HTTPS muszą używać bezpiecznych plików cookie, które wskazują przeglądarkę, że plik cookie powinien być przesyłany tylko przy użyciu Transport Layer Security (TLS).|
|[CA5383: Upewnij się, że używasz bezpiecznych plików cookie na platformie ASP.NET Core](../code-quality/ca5383.md)|Aplikacje dostępne za pośrednictwem protokołu HTTPS muszą używać bezpiecznych plików cookie, które wskazują przeglądarkę, że plik cookie powinien być przesyłany tylko przy użyciu Transport Layer Security (TLS).|
|[CA5384: Nie używaj algorytmu Digital Signature Algorithm (DSA)](../code-quality/ca5384.md)|DSA jest słabym algorytmem szyfrowania.|
|[CA5385: Użyj algorytmu Rivest-Shamir-Adleman (RSA) z wystarczającym rozmiarem klucza](../code-quality/ca5385.md)|Klucz RSA mniejszy niż 2048 bitów jest bardziej narażony na ataki typu "odmowa".|
|[CA5386: Unikaj kodowania na stałe wartości SecurityProtocolType](../code-quality/ca5386.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Protokół TLS 1,0 i TLS 1,1 są przestarzałe, podczas gdy protokoły TLS 1,2 i TLS 1,3 są aktualne. W przyszłości protokoły TLS 1,2 i TLS 1,3 mogą być przestarzałe. Aby upewnić się, że aplikacja pozostaje zabezpieczona, należy unikać zakodowana wersji protokołu i docelowej co najmniej .NET Framework v 4.7.1.|
|[CA5387: Nie używaj funkcji wyprowadzania klucza słabego z niewystarczającą liczbą iteracji](../code-quality/ca5387.md)|Ta reguła sprawdza, czy klucz kryptograficzny został wygenerowany przy <xref:System.Security.Cryptography.Rfc2898DeriveBytes> użyciu liczby iteracji mniejszej niż 100 000. Wyższa liczba iteracji może pomóc wyeliminować ataki słownikowe próbujące złamać wygenerowany klucz kryptograficzny.|
|[CA5388: Używając funkcji wyprowadzania klucza słabego, upewnij się, że istnieje wystarczająca liczba iteracji](../code-quality/ca5388.md)|Ta reguła sprawdza, czy klucz kryptograficzny został wygenerowany za <xref:System.Security.Cryptography.Rfc2898DeriveBytes> pomocą liczby iteracji, która może być mniejsza niż 100 000. Wyższa liczba iteracji może pomóc wyeliminować ataki słownikowe próbujące złamać wygenerowany klucz kryptograficzny.|
|[CA5389: Nie dodawaj ścieżki elementu archiwum do docelowej ścieżki systemu plików](../code-quality/ca5389.md)|Ścieżka pliku może być względna i może prowadzić do dostępu do systemu plików poza oczekiwaną ścieżką docelową systemu plików, co prowadzi do złośliwych zmian konfiguracji i zdalnego wykonywania kodu za pośrednictwem techniki "Ustal i czekaj".|
|[CA5390: Nie zapisuj klucza szyfrowania na stałe w kodzie](../code-quality/ca5390.md)|Aby algorytm symetryczny był prawidłowy, klucz tajny musi być znany tylko nadawcy i odbiornik. Gdy klucz jest zakodowany, można go łatwo odnaleźć. Nawet przy użyciu skompilowanych plików binarnych, złośliwi użytkownicy mogą łatwo go wyodrębnić. Po naruszeniu zabezpieczeń klucza prywatnego tekst szyfru można odszyfrować bezpośrednio i nie jest już chroniony.|
|[CA5391: Użyj tokenów zabezpieczających przed fałszerstwem w kontrolerach MVC platformy ASP.NET Core](../code-quality/ca5391.md)|Obsługa `POST` , `PUT` , `PATCH` , lub `DELETE` żądanie bez weryfikowania tokenu antysfałszowanego może być narażona na ataki fałszerstwa żądań między lokacjami. Atakujący sfałszowanie żądań między lokacjami może wysyłać złośliwych żądań od uwierzytelnionego użytkownika do kontrolera ASP.NET Core MVC.|
|[CA5392: Użyj atrybutu DefaultDllImportSearchPaths dla elementów P/Invoke](../code-quality/ca5392.md)|Domyślnie funkcja P/Invoke korzysta z <xref:System.Runtime.InteropServices.DllImportAttribute> sondowania wielu katalogów, w tym bieżącego katalogu roboczego biblioteki do załadowania. Może to być problem z zabezpieczeniami dla niektórych aplikacji, co prowadzi do przejęcia biblioteki DLL.|
|[CA5393: Nie używaj niebezpiecznej wartości DllImportSearchPath](../code-quality/ca5393.md)|Może istnieć złośliwa Biblioteka DLL w domyślnych katalogach wyszukiwania bibliotek DLL i katalogach zestawów. Lub, w zależności od tego, gdzie jest uruchomiona aplikacja, może istnieć złośliwa Biblioteka DLL w katalogu aplikacji.|
|[CA5394: Nie używaj niezabezpieczonej losowości](../code-quality/ca5394.md)|Użycie kryptografii z kryptograficznie słabym generatorem liczb losowych może pozwolić osobie atakującej na przewidywalność wygenerowania wartości z uwzględnieniem zabezpieczeń.|
|[CA5395: Pomiń atrybut HttpVerb dla metod akcji](../code-quality/ca5395.md)|Wszystkie metody akcji, które tworzą, edytują, usuwają lub w inny sposób modyfikują dane, muszą być chronione przy użyciu atrybutu antysfałszowanego z ataków fałszerstwa żądań między lokacjami. Wykonanie operacji GET powinno być bezpieczną operacją, która nie ma efektów ubocznych i nie modyfikuje utrwalonych danych.|
|[CA5396: Ustaw element HttpOnly na wartość true dla elementu HttpCookie](../code-quality/ca5396.md)|W celu zapewnienia kompleksowej oceny należy zapewnić, że poufne pliki cookie HTTP są oznaczane jako HttpOnly. Oznacza to, że przeglądarki sieci Web powinny uniemożliwić uzyskiwanie dostępu do plików cookie przez skrypty. Wprowadzane złośliwe skrypty są typowym sposobem kradzieży plików cookie.|
|[CA5397: Nie używaj przestarzałych wartości SslProtocols](../code-quality/ca5397.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Starsze wersje protokołu TLS są mniej bezpieczne niż TLS 1,2 i TLS 1,3 i coraz bardziej mogą mieć nowe luki w zabezpieczeniach. Unikaj stosowania starszych wersji protokołów, aby zminimalizować ryzyko.|
|[CA5398: Unikaj zapisanych na stałe wartości SslProtocols](../code-quality/ca5398.md)|Transport Layer Security (TLS) zabezpiecza komunikację między komputerami, najczęściej przy użyciu protokołu Hypertext Transfer Protocol Secure (HTTPS). Protokół TLS 1,0 i TLS 1,1 są przestarzałe, podczas gdy protokoły TLS 1,2 i TLS 1,3 są aktualne. W przyszłości protokoły TLS 1,2 i TLS 1,3 mogą być przestarzałe. Aby upewnić się, że aplikacja pozostaje zabezpieczona, należy unikać zakodowana wersji protokołu.|
|[CA5399: Ostatecznie wyłącz sprawdzenie listy odwołań certyfikatów programu HttpClient](../code-quality/ca5399.md)|Odwołany certyfikat nie jest już zaufany. Mogą one być używane przez osoby atakujące, które przechodzą z pewnych złośliwych danych lub kradzieży poufnych danych w komunikacji przy użyciu protokołu HTTPS.|
|[CA5400: Upewnij się, że sprawdzenie listy odwołań certyfikatów programu HttpClient nie jest wyłączone](../code-quality/ca5400.md)|Odwołany certyfikat nie jest już zaufany. Mogą one być używane przez osoby atakujące, które przechodzą z pewnych złośliwych danych lub kradzieży poufnych danych w komunikacji przy użyciu protokołu HTTPS.|
|[CA5401: Nie używaj metody CreateEncryptor w wektorem inicjowania innym niż domyślny](../code-quality/ca5401.md)|Szyfrowanie symetryczne powinno zawsze używać niepowtarzalnych wektorów inicjalizacji, aby zapobiec atakom słownikowym.|
|[CA5402: Użyj metody CreateEncryptor z domyślnym wektorem inicjowania](../code-quality/ca5402.md)|Szyfrowanie symetryczne powinno zawsze używać niepowtarzalnych wektorów inicjalizacji, aby zapobiec atakom słownikowym.|
