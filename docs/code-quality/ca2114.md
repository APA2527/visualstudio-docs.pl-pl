---
title: 'CA2114: Metody zabezpieczeń powinny być nadzbiorem typu'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- MethodSecurityShouldBeASupersetOfType
- CA2114
helpviewer_keywords:
- CA2114
- MethodSecurityShouldBeASupersetOfType
ms.assetid: 663f7aa4-8be5-4bd5-be92-4e9444f07077
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 4df225b0df6ca44af74c46bfe147ada67c694618
ms.sourcegitcommit: 184e2ff0ff514fb980724fa4b51e0cda753d4c6e
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2019
ms.locfileid: "72565879"
---
# <a name="ca2114-method-security-should-be-a-superset-of-type"></a>CA2114: Metody zabezpieczeń powinny być nadzbiorem typu

|||
|-|-|
|TypeName|MethodSecurityShouldBeASupersetOfType|
|CheckId|CA2114|
|Kategoria|Microsoft.Security|
|Zmiana podziału|Kluczowa|

## <a name="cause"></a>Przyczyna
Typ ma Zabezpieczenia deklaracyjne, a jedna z jej metod ma deklaracyjne zabezpieczenia dla tej samej akcji zabezpieczeń, a akcja zabezpieczeń nie jest [potrzebami konsolidacji](/dotnet/framework/misc/link-demands), a uprawnienia sprawdzane przez typ nie są podzbiorem uprawnień zaewidencjonowanych przez metodę.

> [!NOTE]
> Ta starsza reguła nie jest dostępna w analizatorach FxCop. Aby uzyskać więcej informacji, zobacz [reguły przestarzałe](fxcop-rule-port-status.md#deprecated-rules).

## <a name="rule-description"></a>Opis reguły
Metoda nie powinna mieć zarówno zabezpieczeń deklaratywnych na poziomie metody, jak i na poziomie typu dla tej samej akcji. Dwa kontrole nie są połączone; stosowane jest tylko żądanie na poziomie metody. Na przykład, jeśli typ wymaga uprawnień `X`, a jedna z jej metod wymaga uprawnień `Y`, kod nie musi mieć uprawnień `X`, aby wykonać metodę.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia
Sprawdź swój kod, aby upewnić się, że obie akcje są wymagane. Jeśli wymagane są obie akcje, upewnij się, że akcja na poziomie metody obejmuje zabezpieczenia określone na poziomie typu. Na przykład, jeśli typ wymaga uprawnień `X`, a jego Metoda musi również mieć uprawnienia do `Y`, metoda powinna jawnie wymagać `X` i `Y`.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia
Jeśli metoda nie wymaga zabezpieczeń określonych przez typ, bezpieczniej jest pominąć ostrzeżenie z tej reguły. Nie jest to jednak zwykły scenariusz i może wskazywać potrzebę dokładnego przeglądu projektu.

## <a name="example-1"></a>Przykład 1

W poniższym przykładzie zastosowano uprawnienia środowiska w celu zademonstrowania zagrożeń naruszających tę regułę. W tym przykładzie kod aplikacji tworzy wystąpienie zabezpieczonego typu przed odmową uprawnienia wymaganego przez typ. W rzeczywistym scenariuszu zagrożeń aplikacja będzie wymagać innego sposobu uzyskania wystąpienia obiektu.

W poniższym przykładzie biblioteka wymaga uprawnień do zapisu dla typu i uprawnienia do odczytu dla metody.

[!code-csharp[FxCop.Security.MethodLevelSecurity#1](../code-quality/codesnippet/CSharp/ca2114-method-security-should-be-a-superset-of-type_1.cs)]

## <a name="example-2"></a>Przykład 2

Poniższy kod aplikacji demonstruje lukę w zabezpieczeniach biblioteki, wywołując metodę, mimo że nie spełnia wymagań zabezpieczeń na poziomie typu.

[!code-csharp[FxCop.Security.TestMethodLevelSecurity#1](../code-quality/codesnippet/CSharp/ca2114-method-security-should-be-a-superset-of-type_2.cs)]

Ten przykład generuje następujące wyniki:

```txt
[All permissions] Personal information: 6/16/1964 12:00:00 AM
[No write permission (demanded by type)] Personal information: 6/16/1964 12:00:00 AM
[No read permission (demanded by method)] Could not access personal information: Request failed.
```

## <a name="see-also"></a>Zobacz także

- [Wytyczne dotyczące bezpiecznego programowania](/dotnet/standard/security/secure-coding-guidelines)
- [Wymagania dotyczące linków](/dotnet/framework/misc/link-demands)
- [Dane i modelowanie](/dotnet/framework/data/index)
