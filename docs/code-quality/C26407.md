---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 52eccac6f551d88eb1d39ed0dc0f3e4b8122e674
ms.sourcegitcommit: 1fc6ee928733e61a1f42782f832ead9f7946d00c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/22/2019
ms.locfileid: "60082259"
---
# <a name="c26407-dontheapallocateunnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Aby uniknąć niepotrzebnego stosowania wskaźników podejmowane są próby wykrywania typowych wzorców alokacje lokalnych, na przykład gdy wynik wywołania nowy operator są przechowywane w lokalnej zmiennej lub nowszy jawnie usunięte. Obejmuje to obsługę reguły R.5: *Preferuj obiekty w zakresie, nie przydzielaj niepotrzebnie w stercie*. Sugerowanej poprawki jest używany typ RAII zamiast wskaźnik surowy i zezwala poradzić sobie z zasobami. Jeśli przydział jest pojedynczy obiekt, może być niepotrzebne oczywiście i zmiennej lokalnej typu obiektu będzie działać lepiej.

## <a name="remarks"></a>Uwagi
- Aby zmniejszyć liczbę ostrzeżeń, ten wzorzec jest wykrywany tylko wskaźników właściciela. Tak, należy go oznaczyć właścicieli prawidłowo pierwszy. Firma Microsoft możesz łatwo rozszerzyć, aby obejmuje surowe wskaźniki, jeśli firma Microsoft otrzyma opinie od klientów w odniesieniu do takiego scenariusza.
- Termin obiekt w zakresie mogą być nieco mylące, ale ogólne chodzi o to, czy zalecane jest używanie zmiennej lokalnej, którego okres istnienia są zarządzane automatycznie lub inteligentne obiektu, który skutecznie zarządza zasobami dynamicznych. Obiekty inteligentne mogą oczywiście sterty alokacji, ale nie jest jawną w kodzie.
- Jeśli to ostrzeżenie jest uruchamiana na tablicy alokacji, (który zazwyczaj jest wymagany dynamicznej buforów), poprawki można używać standardowych kontenerów lub `std::unique_pointer<T[]>`.
- Wzorzec jest wykrywane tylko dla zmiennych lokalnych, dzięki czemu firma Microsoft nie ostrzegaj przypadków, gdy przydział jest przypisane, powiedz, zmienna globalna, a następnie usuwany w tej samej funkcji.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Przykład 1: Alokacja niepotrzebne obiektu na stercie

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Przykład 2: Obiekt niepotrzebnych alokacji na stosie (stałe za pomocą lokalnego obiektu)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Przykład 3: Bufor niepotrzebnych alokacji na stercie

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Przykład 4: Bufor niepotrzebnych alokacji na stosie (stałe za pomocą kontenera)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
