---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: a22c80dc20fa8d437cd2aac71a3a857ff4f68165
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261241"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Aby uniknąć niepotrzebnego użycia wskaźników, firma Microsoft próbuje wykryć wspólne wzorce przydziałów lokalnych, na przykład gdy wynik wywołania operatora new jest przechowywany w zmiennej lokalnej i został później jawnie usunięty. Obsługuje to regułę R. 5: *Preferuj obiekty w zakresie, nie należy przydzielać sterty niepotrzebnie*. Sugerowana poprawka to użycie typu RAII zamiast wskaźnika RAW i pozwala na rozproszenie zasobów. Jeśli alokacja jest pojedynczym obiektem, może być oczywiście niepotrzebny, a lokalna zmienna typu obiektu będzie działać lepiej.

## <a name="remarks"></a>Uwagi
- Aby zmniejszyć liczbę ostrzeżeń, ten wzorzec jest wykrywany tylko dla wskaźników właściciela. Dlatego należy najpierw oznaczyć właścicieli odpowiednio do potrzeb. Możemy łatwo ją rozbudować w taki sposób, aby objęła surowe wskaźniki, jeśli firma Microsoft otrzyma opinie od klientów w celu obsługi tego scenariusza.
- Termin dotyczący obiektu może być błędnie mylący, ale ogólnym pomysłem jest to, że sugerujemy użycie lokalnej zmiennej, której okres istnienia jest zarządzany automatycznie, lub obiektu inteligentnego, który efektywnie zarządza zasobami dynamicznymi. Inteligentne obiekty mogą oczywiście przydzielić sterty, ale nie jest to jawne w kodzie.
- Jeśli ostrzeżenie zostanie wyzwolone w alokacji tablicy (co jest zwykle konieczne w przypadku buforów dynamicznych), poprawka może używać standardowych kontenerów lub `std::unique_pointer<T[]>`.
- Wzorzec jest wykrywany tylko dla zmiennych lokalnych, dlatego nie ostrzegamy o przypadkach, w których alokacja alokacji jest przypisana do, powiedzieć, zmienna globalna, a następnie usunięta w tej samej funkcji.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Przykład 1: niepotrzebna alokacja obiektu na stercie

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Przykład 2: niepotrzebna alokacja obiektu na stercie (stała z obiektem lokalnym)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Przykład 3: niepotrzebne alokacja bufora na stercie

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Przykład 4: niepotrzebne alokacja bufora na stercie (naprawiona przy użyciu kontenera)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
