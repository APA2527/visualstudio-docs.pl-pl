---
title: C6053
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6053
helpviewer_keywords:
- C6053
ms.assetid: 8e25566a-e3b9-470a-820d-64221a877c53
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 8b381dfc843d37e6c0a55918566759c9ba3ffe81
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62579037"
---
# <a name="c6053"></a>C6053
Ostrzeżenie C6053: wywołanie \<funkcja > może nie zakończyć zerem ciągu \<zmienna >

 To ostrzeżenie wskazuje, że określona funkcja została wywołana w taki sposób, że ciąg wynikowy może nie być zakończony zerem. Ta wada może spowodować przepełnienie buforu możliwe do wykorzystania lub awarii. To ostrzeżenie zostanie również wygenerowany, jeśli funkcja adnotacjami oczekuje pusty ciąg zakończone jest przekazywany ciąg, który nie ma wartości null zakończony.

 Większość standardowej biblioteki C i Win32 ciągiem, funkcje obsługi wymagają i tworzą ciągi zakończony zerem. Kilka funkcji "liczone ciąg" (w tym `strncpy`, `wcsncpy`, `_mbsncpy`, `_snprintf`, i `snwprintf`) nie tworzą ciągi zakończony zerem, jeśli będą dokładnie wypełniana ich buforu. W tym przypadku zaczną kolejne wywołanie funkcji ciąg, który oczekuje, że ciąg zakończony zerem poza końcem bufor wyszukiwanie od zera. Program należy upewnić się, że ciąg kończy się cyfrą zero. Ogólnie rzecz biorąc należy przekazać o długości do funkcji "liczone ciąg" jeden mniejszy niż rozmiar buforu i jawnie przypisać zero do ostatniego znaku w buforze.

## <a name="example"></a>Przykład
 Następujący przykładowy kod generuje to ostrzeżenie:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource="Hello, World!";

  strncpy(szDest, szSource, MAX);
  return strlen(szDest); // possible crash here
}
```

## <a name="example"></a>Przykład
 Aby poprawić to ostrzeżenie, zakończyć zerem ciągu, jak pokazano w poniższym przykładowym kodzie:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource="Hello, World!";

  strncpy(szDest, szSource, MAX-1);
  szDest[MAX-1]=0;
  return strlen(szDest);
}
```

## <a name="example"></a>Przykład
 Następujący przykładowy kod naprawia, to ostrzeżenie, za pomocą manipulowanie ciągami bezpieczne `strncpy_s` funkcji:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource= "Hello, World!";

  strncpy_s(szDest, sizeof(szDest), szSource, strlen(szSource));
  return strlen(szDest);
}
```

 Należy pamiętać, że to ostrzeżenie jest czasami zgłaszane na niektórych idiomy możemy zagwarantować ich bezpieczeństwa w praktyce. Ze względu na częstotliwość i potencjalne konsekwencje tej wady narzędzie do analizy jest obciążona na rzecz znalezienie potencjalnych problemów, zamiast jego typowe odchylenie redukcji szumów.

## <a name="see-also"></a>Zobacz też

- [Korzystanie z adnotacji SAL w celu zmniejszenia liczby błędów kodu](using-sal-annotations-to-reduce-c-cpp-code-defects.md)
- [strncpy_s, _strncpy_s_l, wcsncpy_s, _wcsncpy_s_l, _mbsncpy_s, _mbsncpy_s_l](/cpp/c-runtime-library/reference/strncpy-s-strncpy-s-l-wcsncpy-s-wcsncpy-s-l-mbsncpy-s-mbsncpy-s-l)