---
title: 'CA2007: Nie oczekuj bezpośrednio zadania'
ms.date: 03/08/2019
ms.topic: reference
f1_keywords:
- CA2007
- DoNotDirectlyAwaitATaskAnalyzer
helpviewer_keywords:
- CA2007
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
ms.openlocfilehash: f55cc992c443b034ccfbf444db4b3ca705b2b698
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/02/2020
ms.locfileid: "89219624"
---
# <a name="ca2007-do-not-directly-await-a-task"></a>CA2007: Nie oczekuj bezpośrednio zadania

|Element|Wartość|
|-|-|
|CheckId|CA2007|
|Kategoria|Microsoft. niezawodność|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna

Metoda asynchroniczna [czeka](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> bezpośrednio.

## <a name="rule-description"></a>Opis reguły

Gdy Metoda asynchroniczna czeka <xref:System.Threading.Tasks.Task> bezpośrednio, kontynuacja zwykle odbywa się w tym samym wątku, który utworzył zadanie, w zależności od kontekstu asynchronicznego. Takie zachowanie może być kosztowne pod względem wydajności i może spowodować zakleszczenie w wątku interfejsu użytkownika. Rozważ wywołanie metody <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> sygnalizującej zamiar kontynuacji.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenia, wywołaj <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> oczekiwane <xref:System.Threading.Tasks.Task> . Można przekazać albo `true` `false` dla `continueOnCapturedContext` parametru.

- Wywołanie `ConfigureAwait(true)` dla zadania ma takie samo zachowanie, jak niejawnie wywoływanie <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> . Jawne wywołanie tej metody polega na tym, że czytelnicy będą wiedzieli, że zamierzasz przeprowadzić kontynuację w oryginalnym kontekście synchronizacji.

- Wywołaj `ConfigureAwait(false)` zadanie, aby zaplanować kontynuacje puli wątków, unikając w ten sposób zakleszczenia w wątku interfejsu użytkownika. Przekazywanie `false` jest dobrym rozwiązaniem dla bibliotek niezależnych od aplikacji.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

To ostrzeżenie jest przeznaczone dla bibliotek, w których kod może być wykonywany w dowolnych środowiskach i gdzie kod nie powinien określać założeń dotyczących środowiska lub jak obiekt wywołujący metody może być wywoływany lub oczekujący na to. Zwykle jest to konieczne, aby całkowicie pominąć ostrzeżenie dla projektów reprezentujących kod aplikacji zamiast kodu biblioteki; w rzeczywistości uruchomienie tej analizatora w kodzie aplikacji (na przykład po kliknięciu przycisku obsługi zdarzeń w programie WinForms lub projekcie WPF) może prowadzić do nieprawidłowych akcji.

To ostrzeżenie można pominąć w każdej sytuacji, w której kontynuacja powinna zostać zaplanowana z powrotem do oryginalnego kontekstu lub w przypadku braku takiego kontekstu. Na przykład podczas pisania kodu na przycisku kliknij program obsługi zdarzeń w aplikacji WinForms lub WPF, w ogólny sposób kontynuacja oczekiwania z Await powinna być uruchamiana w wątku interfejsu użytkownika, a w związku z tym domyślnym zachowaniem planowania kontynuacji z powrotem do głównego kontekstu jest pożądane. Podobnie jak w przypadku pisania kodu w aplikacji ASP.NET Core, domyślnie nie ma <xref:System.Threading.SynchronizationContext> lub <xref:System.Threading.Tasks.TaskScheduler> , dla którego powód nie mógł `ConfigureAwait` faktycznie zmienić żadnego zachowania.

## <a name="example"></a>Przykład

Poniższy fragment kodu generuje ostrzeżenie:

```csharp
public async Task Execute()
{
    Task task = null;
    await task;
}
```

Aby naprawić naruszenie, wywołaj <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> oczekiwane <xref:System.Threading.Tasks.Task> :

```csharp
public async Task Execute()
{
    Task task = null;
    await task.ConfigureAwait(false);
}
```

## <a name="configurability"></a>Określając

Można skonfigurować, czy chcesz wykluczyć metody asynchroniczne, które nie zwracają wartości z tej reguły. Aby wykluczyć te rodzaje metod, Dodaj następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
# Package version 2.9.0 and later
dotnet_code_quality.CA2007.exclude_async_void_methods = true

# Package version 2.6.3 and earlier
dotnet_code_quality.CA2007.skip_async_void_methods = true
```

Można także skonfigurować, do których rodzajów zestawów wyjściowych ma być stosowana ta reguła. Na przykład, aby zastosować tę regułę tylko do kodu generującego aplikację konsolową lub dynamicznie połączonej biblioteki (to nie jest aplikacja interfejsu użytkownika), Dodaj następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA2007.output_kind = ConsoleApplication, DynamicallyLinkedLibrary
```

Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów jakości kodu platformy .NET](configure-fxcop-analyzers.md).

## <a name="see-also"></a>Zobacz też

- [ConfigureAwait — często zadawane pytania](https://devblogs.microsoft.com/dotnet/configureawait-faq/)
- [Czy należy czekać na zadanie z ConfigureAwait (false)?](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md#should-i-await-a-task-with-configureawaitfalse)
- [CA2008: Nie twórz zadań bez przekazania klasy TaskScheduler](ca2008.md)
- [Ostrzeżenia o niezawodności](reliability-warnings.md)
