---
title: C26410
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26410
helpviewer_keywords:
- C26410
ms.assetid: d1547faf-96c6-48da-90f5-841154d0e878
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: a668f824cf53e00a5adf86cdd7052fd8130c2766
ms.sourcegitcommit: 21d667104199c2493accec20c2388cf674b195c3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/08/2019
ms.locfileid: "55937142"
---
# <a name="c26410--noreftoconstuniqueptr"></a>C26410  NO_REF_TO_CONST_UNIQUE_PTR
Ogólnie rzecz biorąc odwołania do unikatowego wskaźnika elementu const są bez znaczenia. Można można bezpiecznie zastąpić pierwotne odwołanie lub wskaźnik.

## <a name="remarks"></a>Uwagi
- Sprawdzanie unikatowego wskaźnika ma dość szeroka kryteria, aby zidentyfikować inteligentnych wskaźników. Reguła R.31: *W przypadku innych niż std inteligentnych wskaźników, wykonaj podstawowy wzorzec z standardowe opisuje unikatowego wskaźnika i udostępnione pojęcia wskaźnika*. Heurystyki jest proste, ale może prowadzić do niespodzianek: typ inteligentnego wskaźnika jest dowolny typ, który definiuje albo operator -> or operator\*; kopia stanie typu (wspólny wskaźnik) musi mieć konstruktora kopiującego publicznego lub operator przypisania przeciążona który zajmuje się parametr przekazany przez odwołanie bez do R-wartości.
- Kod szablonu może dać wiele szumu. Należy pamiętać, że szablony mogą być utworzone z różnymi parametrami typu z różnymi poziomami pośredni, w tym odwołania. Ostrzeżenia mogą nie być oczywista i poprawki mogą wymagać niektóre przeróbek szablonów (na przykład jawnego usuwania pośrednie odwołanie). Jeśli kod szablonu jest celowo ogólna, można pominąć to ostrzeżenie.

## <a name="example-1-unnecessary-reference"></a>Przykład 1: Niepotrzebne odniesienia
```cpp
std::vector<std::unique_ptr<Tree>> roots = GetRoots();
std::for_each(
    roots.begin(),
    roots.end(),
    [](const auto &root) { Rebalance(root.get()); });   // C26410
```