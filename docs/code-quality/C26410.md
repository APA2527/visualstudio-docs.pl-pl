---
title: C26410
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26410
helpviewer_keywords:
- C26410
ms.assetid: d1547faf-96c6-48da-90f5-841154d0e878
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 4e643be6cea083b50a421d1ffd6ba985b5deb044
ms.sourcegitcommit: 1fc6ee928733e61a1f42782f832ead9f7946d00c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/22/2019
ms.locfileid: "60051898"
---
# <a name="c26410--noreftoconstuniqueptr"></a>C26410  NO_REF_TO_CONST_UNIQUE_PTR
Ogólnie rzecz biorąc odwołania do unikatowego wskaźnika elementu const są bez znaczenia. Można można bezpiecznie zastąpić pierwotne odwołanie lub wskaźnik.

## <a name="remarks"></a>Uwagi
- Sprawdzanie unikatowego wskaźnika ma dość szeroka kryteria, aby zidentyfikować inteligentnych wskaźników. Reguła R.31: *W przypadku innych niż std inteligentnych wskaźników, wykonaj podstawowy wzorzec z standardowe opisuje unikatowego wskaźnika i udostępnione pojęcia wskaźnika*. Heurystyki jest proste, ale może prowadzić do niespodzianek: typ inteligentnego wskaźnika jest dowolny typ, który definiuje albo operator -> or operator\*; kopia stanie typu (wspólny wskaźnik) musi mieć konstruktora kopiującego publicznego lub operator przypisania przeciążona który zajmuje się parametr przekazany przez odwołanie bez do R-wartości.
- Kod szablonu może dać wiele szumu. Należy pamiętać, że szablony mogą być utworzone z różnymi parametrami typu z różnymi poziomami pośredni, w tym odwołania. Ostrzeżenia mogą nie być oczywista i poprawki mogą wymagać niektóre przeróbek szablonów (na przykład jawnego usuwania pośrednie odwołanie). Jeśli kod szablonu jest celowo ogólna, można pominąć to ostrzeżenie.

## <a name="example-1-unnecessary-reference"></a>Przykład 1: Niepotrzebne odniesienia

```cpp
std::vector<std::unique_ptr<Tree>> roots = GetRoots();
std::for_each(
    roots.begin(),
    roots.end(),
    [](const auto &root) { Rebalance(root.get()); });   // C26410
```