---
title: C6328
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6328
helpviewer_keywords:
- C6328
ms.assetid: e25b00fa-d344-4dc9-b322-b4f1ae06f315
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 7994727d7ebe37896e9a56904b4266a66407eb51
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2019
ms.locfileid: "72017617"
---
# <a name="c6328"></a>C6328

Ostrzeżenie C6328: Niezgodność rozmiaru: \<type > przeniesiona jako parametr \<number >, gdy @no__t 2type > jest wymagana w wywołaniu \<function >

Przekazywanie argumentu typu `char` do środowiska uruchomieniowego języka C, procedur opartych na znakach o nazwie `is<xxx>()`, na przykład `isspace()`, mogą mieć nieprzewidywalne wyniki. Na przykład jeden jednobajtowy znak SBCS lub MBCS typu `char` o wartości większej niż `0x7F` jest wartością ujemną. W przypadku przekazanie `char` kompilator może przekonwertować wartość na podpisaną `int` lub podpisany `long`. Ta wartość może być poddana zarejestrowaniu przez kompilator z nieoczekiwanymi wynikami. Na przykład `isspace` akceptuje argument typu `int`; jednak prawidłowy zakres wartości dla jego argumentu wejściowego to:

`0 <= c <= 255` i wartość specjalna `EOF`.

## <a name="example"></a>Przykład

Domyślnie, `char` jest podpisanym typem w wizualizacji C++, więc zakres wartości zmiennej typu char jest `-128 <= c <= 127`. W związku z tym, jeśli wykonano następujące czynności, `c` zostałyby poddane rejestracji do podpisanego `int` o wartości-37, która jest poza prawidłowym zakresem dla [isspace](/cpp/standard-library/locale-functions#isspace):

```cpp
#include <iostream>

void f( )
{
    char c = -37;
    int retVal = isspace( c );
    // code ...
}
```

Aby rozwiązać ten problem, można użyć `static_cast`, jak pokazano w poniższym kodzie:

```cpp
#include <iostream>

void f( )
{
    char c = -37;
    int retVal = isspace( static_cast<unsigned char> (c) );
    // code ...
}
```

Ostrzeżenie C6328 istnieje przede wszystkim do przechwycenia tego błędu. W przypadku znaków w 7-bitowym zakresie ASCII Rzutowanie jest zbędne. Znaki spoza tego zakresu mogą mieć nieprzewidywalne wyniki, na przykład błąd programu i zakończenie.
