---
title: C6328
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6328
helpviewer_keywords:
- C6328
ms.assetid: e25b00fa-d344-4dc9-b322-b4f1ae06f315
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 0df1626bce13b53e5f612e28002fe77e072491af
ms.sourcegitcommit: e98db44f3a33529b0ba188d24390efd09e548191
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2019
ms.locfileid: "71253289"
---
# <a name="c6328"></a>C6328

Ostrzeżenie C6328: Niezgodność rozmiaru \<: Typ > przeszedł \<jako numer parametru \<, >, gdy typ > jest \<wymagany w wywołaniu funkcji >

Przekazywanie argumentu typu `char` do środowiska uruchomieniowego języka C, procedur opartych na znakach o nazwie `is<xxx>()`, `isspace()`na przykład, może mieć nieprzewidywalne wyniki. Na przykład jeden jednobajtowy znak typu `char` SBCS lub MBCS o wartości większej niż `0x7F` jest wartością ujemną. Jeśli zostanie przesłany, kompilator może przekonwertować wartość na `int` podpisaną lub a `long`. `char` Ta wartość może być poddana zarejestrowaniu przez kompilator z nieoczekiwanymi wynikami. Na przykład `isspace` akceptuje argument typu `int`, jednak prawidłowy zakres wartości dla jego argumentu wejściowego to:

`0 <= c <= 255`oraz wartość `EOF`specjalna.

## <a name="example"></a>Przykład

Domyślnie `char` jest typu ze znakiem w wizualizacji C++, więc zakres wartości zmiennej typu char to `-128 <= c <= 127`. W związku z tym, jeśli zostały wykonane `c` następujące czynności, zostałyby one poddane rejestracji `int` do podpisanej przy użyciu wartości-37, która jest poza prawidłowym zakresem dla [isspace](/cpp/standard-library/locale-functions#isspace):

```cpp
#include <iostream>

void f( )
{
    char c = -37;
    int retVal = isspace( c );
    // code ...
}
```

Aby rozwiązać ten problem, można użyć `static_cast`, jak pokazano w poniższym kodzie:

```cpp
#include <iostream>

void f( )
{
    char c = -37;
    int retVal = isspace( static_cast<unsigned char> (c) );
    // code ...
}
```

Ostrzeżenie C6328 istnieje przede wszystkim do przechwycenia tego błędu. W przypadku znaków w 7-bitowym zakresie ASCII Rzutowanie jest zbędne. Znaki spoza tego zakresu mogą mieć nieprzewidywalne wyniki, na przykład błąd programu i zakończenie.
