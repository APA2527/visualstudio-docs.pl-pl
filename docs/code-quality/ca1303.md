---
title: 'CA1303: Nie przekazuj literałów jako zlokalizowanych parametrów'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: d5b89a038dca5b8a0c19a61ab6c7597896314095
ms.sourcegitcommit: d20ce855461c240ac5eee0fcfe373f166b4a04a9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/29/2020
ms.locfileid: "84182199"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: Nie przekazuj literałów jako zlokalizowanych parametrów

|||
|-|-|
|CheckId|CA1303|
|Kategoria|Microsoft. Globalizacja|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna

Metoda przekazuje literał ciągu jako parametr do konstruktora lub metody .NET, a ten ciąg powinien być Lokalizowalny.

To ostrzeżenie jest zgłaszane, gdy ciąg literału zostanie przesunięty jako wartość do parametru lub właściwości, co najmniej jeden z następujących przypadków ma wartość true:

- <xref:System.ComponentModel.LocalizableAttribute>Atrybut parametru lub właściwości jest ustawiony na wartość true.

- Nazwa parametru ciągu, który jest przesyłany do konsoli. Write lub Console. WriteLine ma wartość "value" lub "format".

Domyślnie ta reguła analizuje całą bazę kodu, ale [można to skonfigurować](#excluded-type-names-with-derived-types).

Począwszy od wersji 3.0.0 pakietu analizatora, heurystyka nazw nie jest już używana domyślnie, ale jest to możliwe do [skonfigurowania](#use-naming-heuristic).

## <a name="rule-description"></a>Opis reguły

Literały ciągu, które są osadzone w kodzie źródłowym, są trudne do zlokalizowania.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, Zastąp literał ciągu ciągiem pobranym przez wystąpienie <xref:System.Resources.ResourceManager> klasy.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

Jeśli biblioteka kodu nie zostanie zlokalizowana, można bezpiecznie pominąć ostrzeżenie z tej reguły lub jeśli nie jest on widoczny dla użytkownika końcowego lub dewelopera przy użyciu biblioteki kodu.

Użytkownicy mogą wyeliminować hałas względem metod, które nie powinny być przenoszone do zlokalizowanych ciągów przez zmianę nazwy parametru lub właściwości lub poprzez oznaczenie tych elementów jako warunku.

## <a name="configurability"></a>Określając

Jeśli uruchamiasz tę regułę z [analizatorów FxCop](install-fxcop-analyzers.md) (a nie ze starszą analizą), tę regułę można skonfigurować.

### <a name="excluded-type-names-with-derived-types"></a>Wykluczone nazwy typów z typami pochodnymi

Można skonfigurować typy, w tym ich typy pochodne, do wykluczenia z analizy. Na przykład, aby określić, że reguła nie powinna być uruchamiana na żadnej metodzie w typach o nazwach `MyType` i jego typach pochodnych, Dodaj następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Dozwolone formaty nazw symboli w wartości opcji (oddzielone znakiem "|"):

- Tylko nazwa typu (obejmuje wszystkie typy z nazwą, niezależnie od typu zawierającego lub przestrzeni nazw)
- W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu z opcjonalnym `T:` prefiksem.

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Dopasowuje wszystkie typy o nazwie "MyType" i wszystkie jego typy pochodne w kompilacji
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Dopasowuje wszystkie typy o nazwie "MyType1" lub "MyType2" i wszystkie ich typy pochodne w kompilacji
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Dopasowuje określony typ "MyType" o podanej w pełni kwalifikowanej nazwie i wszystkich jej typach pochodnych
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Dopasowuje określone typy "MyType1" i "MyType2" z odpowiednimi w pełni kwalifikowanymi nazwami i wszystkimi typami pochodnymi

Tę opcję można skonfigurować tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (globalizacja). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów FxCop](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Użyj algorytmu heurystycznego nazewnictwa

Można skonfigurować, czy parametry lub nazwy właściwości zawierające tekst "text", "Message" lub "Caption" będą wyzwalać tę regułę.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Przykład

Poniższy przykład przedstawia metodę, która zgłasza wyjątek, gdy jeden z dwóch argumentów jest poza zakresem. Dla pierwszego argumentu Konstruktor wyjątku jest przenoszona jako ciąg literału, co narusza tę regułę. Dla drugiego argumentu Konstruktor prawidłowo przeszedł ciąg pobrany przez <xref:System.Resources.ResourceManager> .

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Zobacz także

- [Zasoby w aplikacjach klasycznych](/dotnet/framework/resources/index)
- [Żądanie społeczności dotyczące zmiany zachowania](https://github.com/dotnet/roslyn-analyzers/issues/2933)
