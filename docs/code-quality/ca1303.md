---
title: 'CA1303: Nie należy przekazywać literałów jako parametrów zlokalizowanych'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: e6b4fad16bc1c4b205ea09a39af8d38e08db848f
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/21/2020
ms.locfileid: "81649144"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: Nie należy przekazywać literałów jako parametrów zlokalizowanych

|||
|-|-|
|TypeName|DoNotPassLiteralsAsLocalizedParameters|
|CheckId|CA1303|
|Kategoria|Globalizacja firmy Microsoft.Globalizacja|
|Przełomowa zmiana|Nierozrywając się|

## <a name="cause"></a>Przyczyna

Metoda przekazuje literału ciągu jako parametr do konstruktora lub metody .NET i ten ciąg powinien być zlokalizowany.

To ostrzeżenie jest wywoływane, gdy ciąg literał jest przekazywany jako wartość do parametru lub właściwości i co najmniej jeden z następujących przypadków jest spełniony:

- Atrybut <xref:System.ComponentModel.LocalizableAttribute> parametru lub właściwości jest ustawiona na true.

- Nazwa parametru ciągu, który jest przekazywany do Console.Write lub Console.WriteLine metoda jest "value" lub "format".

Domyślnie ta reguła analizuje całą bazę kodu, ale jest [konfigurowalna](#excluded-type-names-with-derived-types).

Począwszy od wersji 3.0.0 pakietu analizatora, heurystyka nazewnictwa nie jest już używana domyślnie, ale jest [konfigurowalna](#use-naming-heuristic).

## <a name="rule-description"></a>Opis reguły

Literały ciągów, które są osadzone w kodzie źródłowym są trudne do zlokalizowania.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, zastąp literał ciągu ciągiem pobranym za pośrednictwem wystąpienia <xref:System.Resources.ResourceManager> klasy.

## <a name="when-to-suppress-warnings"></a>Kiedy należy pomijać ostrzeżenia

Można bezpiecznie pominąć ostrzeżenie od tej reguły, jeśli biblioteka kodu nie będzie zlokalizowana lub jeśli ciąg nie jest narażony na użytkownika końcowego lub dewelopera przy użyciu biblioteki kodu.

Użytkownicy mogą wyeliminować hałas przed metodami, które nie powinny być przekazywane zlokalizowane ciągi przez zmianę nazwy parametru lub właściwości lub oznaczanie tych elementów jako warunkowe.

## <a name="configurability"></a>Konfiguracji

Jeśli uruchamiasz tę regułę z [analizatorów FxCop](install-fxcop-analyzers.md) (a nie z starszą analizą), ta reguła jest konfigurowalna.

### <a name="excluded-type-names-with-derived-types"></a>Wykluczone nazwy typów z typami pochodnymi

Można skonfigurować typy, w tym jego typy pochodne, aby wykluczyć z analizy. Na przykład, aby określić, że reguła nie `MyType` powinna być uruchamiana na żadnych metodach w ramach typów nazwanych i jej typów pochodnych, dodaj następującą parę klucz-wartość do pliku .editorconfig w projekcie:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Dozwolone formaty nazw symboli w wartości opcji (oddzielone '|'):

- Nazwa typu tylko (obejmuje wszystkie typy o nazwie, niezależnie od typu zawierającego lub obszaru nazw)
- W pełni kwalifikowane nazwy w [formacie identyfikatora](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format) `T:` dokumentacji symbolu z opcjonalnym prefiksem.

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Dopasowuje wszystkie typy o nazwie "MyType" i wszystkie jego typy pochodne w kompilacji
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Dopasowuje wszystkie typy o nazwie "MyType1" lub "MyType2" i wszystkie ich typy pochodne w kompilacji
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Dopasowuje określony typ "MyType" z podana w pełni kwalifikowaną nazwą i wszystkimi jego typami pochodnymi
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Dopasowuje określone typy "MyType1" i "MyType2" z odpowiednimi w pełni kwalifikowanymi nazwami i wszystkimi ich typami pochodnymi

Tę opcję można skonfigurować tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (Globalizacja). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów FxCop](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Użyj heurystyki nazewnictwa

Można skonfigurować, czy parametry lub nazwy właściwości zawierające "Tekst", "Wiadomość" lub "Podpis" wyzwoli tę regułę.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Przykład

Poniższy przykład przedstawia metodę, która zgłasza wyjątek, gdy jeden z jego dwóch argumentów są poza zakresem. Dla pierwszego argumentu konstruktor wyjątku jest przekazywany ciąg literał, który narusza tę regułę. Dla drugiego argumentu konstruktor jest poprawnie przekazywany ciąg pobrany przez <xref:System.Resources.ResourceManager>.

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Zobacz też

- [Zasoby w aplikacjach klasycznych](/dotnet/framework/resources/index)
- [Wniosek społeczności o zmianę zachowania](https://github.com/dotnet/roslyn-analyzers/issues/2933)
