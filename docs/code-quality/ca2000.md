---
title: 'CA2000: Usuwanie obiektów przed utratą zakresu'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615569"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Usuwanie obiektów przed utratą zakresu

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Kategoria|Microsoft.Reliability|
|Przełomowa zmiana|Nierozrywając się|

## <a name="cause"></a>Przyczyna

Obiekt lokalny <xref:System.IDisposable> typu jest tworzony, ale obiekt nie jest usuwany przed wszystkie odwołania do obiektu są poza zakresem.

Domyślnie ta reguła analizuje całą bazę kodu, ale jest [konfigurowalna](#configurability).

## <a name="rule-description"></a>Opis reguły

Jeśli obiekt jednorazowego użytku nie jest jawnie usuwane przed wszystkie odwołania do niego są poza zakresem, obiekt będzie usuwany w pewnym nieokreślonym czasie, gdy moduł zbierający elementy bezużyteczne uruchamia finalizatora obiektu. Ponieważ może wystąpić zdarzenie wyjątkowe, które uniemożliwi uruchamianie finalizatora obiektu, obiekt powinien być jawnie usuwany.

### <a name="special-cases"></a>Specjalne przypadki

Reguła CA2000 nie jest uruchamiana dla obiektów lokalnych następujących typów, nawet jeśli obiekt nie jest usuwany:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Przekazywanie obiektu jednego z tych typów do konstruktora, a następnie *przypisanie* go do pola wskazuje przeniesienie własności do nowo skonstruowanego typu. Oznacza to, że nowo skonstruowany typ jest teraz odpowiedzialny za usuwanie obiektu. Jeśli kod przekazuje obiekt jednego z tych typów do konstruktora, nie występuje naruszenie reguły CA2000, nawet jeśli obiekt nie jest usuwany przed wszystkie odwołania do niego są poza zakresem.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, wywołać <xref:System.IDisposable.Dispose%2A> obiekt, zanim wszystkie odwołania do niego są poza zakresem.

Instrukcji [ `using` (w](/dotnet/csharp/language-reference/keywords/using-statement) [`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) języku Visual Basic) można użyć <xref:System.IDisposable>do zawijania obiektów, które implementują . Obiekty, które są zawijane w ten sposób `using` są automatycznie usuwane na końcu bloku. Jednak następujące sytuacje nie powinny lub nie `using` mogą być obsługiwane za pomocą instrukcji:

- Aby zwrócić obiekt jednorazowego użytku, obiekt `try/finally` musi być `using` skonstruowany w bloku poza blokiem.

- Nie inicjuj członków obiektu jednorazowego `using` użytku w konstruktorze instrukcji.

- Gdy konstruktory, które są chronione tylko przez jeden program obsługi wyjątków są zagnieżdżone w [części nabycia `using` instrukcji,](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)błąd w konstruktorze zewnętrznym może spowodować obiekt utworzony przez konstruktora zagnieżdżonego nigdy nie jest zamknięty. W poniższym przykładzie błąd <xref:System.IO.StreamReader> w konstruktorze może spowodować, że <xref:System.IO.FileStream> obiekt nigdy nie zostanie zamknięty. Ca2000 flagi naruszenie reguły w tym przypadku.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Obiekty dynamiczne powinny używać obiektu cienia <xref:System.IDisposable> do zaimplementowania wzorca dysponowania obiektami.

## <a name="when-to-suppress-warnings"></a>Kiedy należy pomijać ostrzeżenia

Nie należy pomijać ostrzeżenia od tej reguły, chyba że:

- Na obiekcie została wywołana `Dispose`metoda, na przykład<xref:System.IO.Stream.Close%2A>
- Metoda, która wywołała ostrzeżenie <xref:System.IDisposable> zwraca obiekt, który zawija obiekt
- Metoda przydzielania nie ma własności; oznacza to, że odpowiedzialność za usunięcie obiektu jest przenoszona do innego obiektu lub otoki, która jest tworzona w metodzie i zwracana do obiektu wywołującego

## <a name="configurability"></a>Konfiguracji

Jeśli uruchamiasz tę regułę z [analizatorów FxCop](install-fxcop-analyzers.md) (a nie z starszą analizą), możesz skonfigurować analizę dla tej reguły.

### <a name="excluded-symbol-names"></a>Wykluczone nazwy symboli

Można skonfigurować, które części bazy kodu, aby wykluczyć z analizy. Na przykład, aby określić, że reguła nie `MyType`powinna być uruchamiana na żadnym kodzie w ramach typów o nazwie, dodaj następującą parę klucz-wartość do pliku .editorconfig w projekcie:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Dozwolone formaty nazw symboli w wartości opcji (oddzielone '|'):
  - Tylko nazwa symbolu (zawiera wszystkie symbole z nazwą, niezależnie od typu zawierającego lub obszaru nazw)
  - W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu . Każda nazwa symbolu wymaga prefiksu rodzaju symbolu, takiego jak prefiks "M:" dla metod, prefiks "T:" dla typów, prefiks "N:" dla obszarów nazw itp.
  - `.ctor`dla konstruktorów i `.cctor` konstruktorów statycznych

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Dopasowuje wszystkie symbole o nazwie "MyType" w kompilacji
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Dopasowuje wszystkie symbole o nazwie "MyType1" lub "MyType2" w kompilacji
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Pasuje do określonej metody "MyMethod" z danym w pełni kwalifikowanym podpisem
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Dopasowuje określone metody "MyMethod1" i "MyMethod2" z odpowiednim podpisem w pełni kwalifikowanym

Można skonfigurować wszystkie te opcje tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (Projekt). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Powiązane reguły

- [CA2213: Pola możliwe do likwidacji powinny zostać zlikwidowane](../code-quality/ca2213.md)
- [CA2202: Nie likwiduj obiektów wiele razy](../code-quality/ca2202.md)

## <a name="example"></a>Przykład

Jeśli implementujesz metodę, która zwraca jednorazowe obiektu, użyj try/finally bloku bez bloku catch, aby upewnić się, że obiekt jest usuwany. Za pomocą try/finally bloku, można zezwolić na wyjątki, które mają być wywoływane w punkcie błędu i upewnij się, że obiekt jest usuwany.

W Metodzie OpenPort1 wywołanie otwarcia obiektu ISerializable SerialPort lub wywołanie SomeMethod może zakończyć się niepowodzeniem. Ostrzeżenie CA2000 jest wywoływane w tej implementacji.

W metodzie OpenPort2 dwa obiekty SerialPort są deklarowane i ustawiane na wartość null:

- `tempPort`, który jest używany do testowania, czy operacje metody zakończyć się pomyślnie.

- `port`, który jest używany dla wartości zwracanej metody.

Jest `tempPort` zbudowany i otwarty `try` w bloku, a wszelkie inne wymagane `try` prace są wykonywane w tym samym bloku. Na `try` końcu bloku otwarty port jest przypisywany `port` do obiektu, który `tempPort` zostanie zwrócony, a obiekt jest ustawiony na `null`.

Blok `finally` sprawdza wartość `tempPort`. Jeśli nie jest null, operacja w metodzie `tempPort` nie powiodła się i jest zamknięty, aby upewnić się, że wszystkie zasoby są zwalniane. Zwrócony obiekt portu będzie zawierał otwarty obiekt SerialPort, jeśli operacje metody zakończyły się pomyślnie lub będzie null, jeśli operacja nie powiodła się.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Przykład

Domyślnie kompilator języka Visual Basic ma wszystkie operatory arytmetyczne sprawdzić przepełnienie. W związku z tym każda operacja arytmetyczna języka Visual Basic może rzucić . <xref:System.OverflowException> Może to prowadzić do nieoczekiwanych naruszeń w regułach, takich jak CA2000. Na przykład następująca funkcja CreateReader1 spowoduje naruszenie CA2000, ponieważ kompilator języka Visual Basic emituje instrukcję sprawdzania przepełnienia dla dodatku, który może zgłosić wyjątek, który spowodowałby, że StreamReader nie zostanie usunięty.

Aby rozwiązać ten problem, można wyłączyć emitowanie kontroli przepełnienia przez kompilator języka Visual Basic w projekcie lub można zmodyfikować kod, jak w poniższej funkcji CreateReader2.

Aby wyłączyć emitowanie kontroli przepełnienia, kliknij prawym przyciskiem myszy nazwę projektu w Eksploratorze rozwiązań, a następnie kliknij polecenie **Właściwości**. Kliknij **pozycję Skompiluj**, kliknij pozycję **Zaawansowane opcje kompilacji**, a następnie zaznacz pole **wyboru Usuń sprawdzanie przepełnienia liczby całkowitej**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Zobacz też

- <xref:System.IDisposable>
- [Wzorzec Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
