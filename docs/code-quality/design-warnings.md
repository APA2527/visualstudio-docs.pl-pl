---
title: Ostrzeżenia projektu
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 5dc55cc72f7f37482b4396784ca90dba773fdcee
ms.sourcegitcommit: 5ab22b8601db9c420691f8e57abe140e837aa720
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/24/2020
ms.locfileid: "82109471"
---
# <a name="design-warnings"></a>Ostrzeżenia dotyczące projektu

Obsługa ostrzeżeń dotyczących projektowania przystąpienie do [.NET Framework wytycznych dotyczących projektowania](/dotnet/standard/design-guidelines/).

## <a name="in-this-section"></a>W tej sekcji

| Reguła | Opis |
| - | - |
| [CA1000: Nie deklaruj składowych statycznych w typach ogólnych](../code-quality/ca1000.md) | Po wywołaniu statycznego elementu członkowskiego typu ogólnego dla typu trzeba określić argument typu. Po wywołaniu wystąpienia ogólnego elementu członkowskiego, które nie obsługuje wnioskowania, dla elementu członkowskiego musi zostać określony argument typu. W tych dwóch przypadkach składnia określająca argument typu jest różna i łatwo o pomyłkę. |
| [CA1001: Typy z polami możliwymi do likwidacji powinny być możliwe do likwidacji](../code-quality/ca1001.md) | Klasa deklaruje i implementuje pole wystąpienia, które jest typem system. IDisposable, a Klasa nie implementuje interfejsu IDisposable. Klasa, która deklaruje pole IDisposable, pośrednio posiada niezarządzany zasób i powinna implementować interfejs IDisposable. |
| [CA1002: Nie ujawniaj list ogólnych](../code-quality/ca1002.md) | System. Collections. Generic. list< ( \<of (T>) >) to ogólna kolekcja, która została zaprojektowana pod kątem wydajności, a nie dziedziczenia. Dlatego też lista nie zawiera wirtualnych elementów członkowskich. Zamiast powyższych powinny zostać zastosowane kolekcje ogólne, zaprojektowane do obsługi dziedziczenia. |
| [CA1003: Użyj wystąpień ogólnej procedury obsługi zdarzeń](../code-quality/ca1003.md) | Typ zawiera delegata zwracającego wartość void, którego sygnatura zawiera dwa parametry (pierwszy obiekt i drugi typ, który można przypisać do EventArgs), oraz element docelowy zawierający zestaw .NET Framework 2,0. |
| [CA1004: Metody ogólne powinny udostępniać parametr typu](../code-quality/ca1004.md) | Wnioskowanie to ustalenie argumentu typu metody ogólnej przez typ argumentu przekazanego do metody, zamiast użycia jawnej specyfikacji argumentu typu. Aby włączyć wnioskowanie, podpis parametru metody ogólnej musi zawierać parametr, który jest tego samego typu co parametr typu dla metody. W tym przypadku argument typu nie musi zostać określony. Jeśli używasz wnioskowania dla wszystkich parametrów typu, składnia wywołania metod ogólnych i nieogólnych jest taka sama; upraszcza to użyteczność metod ogólnych. |
| [CA1005: Unikaj nadużywania parametrów na typach generycznych](../code-quality/ca1005.md) | Im więcej parametrów typu zawiera typ ogólny, tym trudniej poznać i zapamiętać, co reprezentuje każdy z nich. Zwykle jest to oczywiste z jednym parametrem typu, jak w\<liście T>, a w niektórych przypadkach z dwoma parametrami typu, tak\<jak w przypadku słownika TKey, TValue>. Jeśli jednak istnieją więcej niż dwa parametry typu, poziom trudności staje się zbyt wysoki dla większości użytkowników. |
| [CA1006: Nie zagnieżdżaj typów generycznych w podpisach elementu członkowskiego](../code-quality/ca1006.md) | Argument typu zagnieżdżonego jest argumentem typu, który jest również typem ogólnym. Aby wywołać element członkowski, którego podpis zawiera argument typu zagnieżdżonego, użytkownik musi zainicjować wystąpienie pierwszego typu ogólnego i przekazać go do konstruktora drugiego typu ogólnego. Wymagana procedura oraz składnia są złożone i należy ich unikać. |
| [CA1007: Używaj danych generycznych wszędzie, gdzie jest to odpowiednie](../code-quality/ca1007.md) | Metoda widoczna na zewnątrz zawiera parametr przekazany przez odwołanie do typu System.Object. Użycie metody ogólnej umożliwia przekazanie wszystkich typów podlegających ograniczeniom do metody, bez uprzedniego rzutowania typu do typu parametru przekazanego przez odwołanie. |
| [CA1008: Wyliczenia powinny zawierać wartość zero](../code-quality/ca1008.md) | Wartość domyślna niezainicjowanego typu wyliczeniowego, podobnie jak inne typy wartości, wynosi zero. Wyliczenie atrybutów bez flag powinno definiować składową przy użyciu wartości zero, aby wartość domyślna była prawidłową wartością wyliczenia. Jeśli wyliczenie, w którym zastosowano atrybut FlagsAttribute, definiuje element członkowski o wartości zero, powinno być nazwane „Brak”, aby wskazać, że żadne wartości nie zostały ustawione w wyliczeniu. |
| [CA1009: Należy poprawnie zadeklarować obsługę zdarzenia](../code-quality/ca1009.md) | Metody obsługi zdarzeń przyjmują dwa parametry. Pierwszy jest typu System.Object i nosi nazwę „nadawca”. Jest to obiekt, który wywołał zdarzenie. Drugi parametr jest typu System.EventArgs i nosi nazwę „e”. To dane, które są skojarzone ze zdarzeniem. Metody obsługi zdarzeń nie powinny zwracać wartości; w języku programowania C# jest to wskazywane przez zwrócony typ void. |
| [CA1010: Kolekcje powinny implementować interfejs ogólny](../code-quality/ca1010.md) | Aby poszerzyć użyteczność kolekcji, zaimplementuj jeden z interfejsów kolekcji generycznej. Następnie kolekcja może zostać użyta, aby wypełnić typy generyczne kolekcji. |
| [CA1011: Rozważ przekazanie typów podstawowych jako parametrów](../code-quality/ca1011.md) | Jeśli typ podstawowy jest określony jako parametr w deklaracji metody, dowolny typ, który pochodzi od typu podstawowego, może zostać przekazany jako odpowiadający argument do metody. Jeśli dodatkowa funkcjonalność dostarczana przez typ parametru pochodnego nie jest wymagana, użycie typu podstawowego umożliwia szersze wykorzystanie metody. |
| [CA1012: Typy abstrakcyjne nie powinny mieć konstruktorów](../code-quality/ca1012.md) | Konstruktory dla typów abstrakcyjnych mogą być wywoływane tylko przez typy pochodne. Ze względu na to, że publiczne konstruktory tworzą wystąpienia typu, a nie można utworzyć wystąpienia typu abstrakcyjnego, publiczny konstruktor typu abstrakcyjnego został niepoprawnie zaprojektowany. |
| [CA1013: Przeciąż operator equals przeciążając operatory add i subtract](../code-quality/ca1013.md) | Typ publiczny lub chroniony implementuje operatory dodawania lub odejmowania bez implementowania operatora porównania. |
| [CA1014: Oznacz zestawy atrybutem CLSCompliant](../code-quality/ca1014.md) | The Common Language Specification (CLS) definiuje ograniczenia nazw, typów danych i reguł, z którymi muszą być zgodne zestawy, jeśli zostaną użyte w językach programowania. Dobry projekt wymusza, że wszystkie zestawy jawnie wskazują zgodność ze specyfikacją CLS przy użyciu CLSCompliantAttribute. Jeśli ten atrybut nie jest obecny w zestawie, oznacza to, że zestaw jest niezgodny. |
| [CA1016: Oznacz zestawy atrybutem AssemblyVersion](../code-quality/ca1016.md) | Platforma .NET używa numeru wersji do unikatowego identyfikowania zestawu i powiązania z typami w zestawach o silnej nazwie. Numer wersji jest używany razem z zasadami wersji i wydawcy. Domyślnie aplikacje są uruchamiane tylko z wersji zestawu, z którego zostały zbudowane. |
| [CA1017: Oznacz zestawy za pomocą ComVisibleAttribute](../code-quality/ca1017.md) | ComVisibleAttribute określa, w jaki sposób klienci COM otrzymują dostęp do kodu zarządzanego. Zasada dobrego projektowania nakazuje, aby zestawy jawnie wskazywały widoczność COM. Widoczność COM można ustawić dla całego zestawu, a następnie zastąpić dla poszczególnych typów i elementów członkowskich typu. Jeśli ten atrybut jest nieobecny, zawartość zestawu jest widoczna dla klientów COM. |
| [CA1018: Oznacz atrybuty AttributeUsageAttribute](../code-quality/ca1018.md) | Podczas definiowania atrybutu niestandardowego należy go oznaczyć przy użyciu elementu AttributeUsageAttribute, aby wskazać, w którym miejscu kodu źródłowego ma być on zastosowany. Znaczenie i zamierzone użycie atrybutu określi jego prawidłowe lokalizacje w kodzie. |
| [CA1019: Zdefiniuj metody dostępu do argumentów atrybutu](../code-quality/ca1019.md) | Atrybuty mogą definiować obowiązkowe argumenty, które trzeba określić, aby móc zastosować atrybut do obiektu docelowego. Znane są również jako argumenty pozycyjne, ponieważ są one dostarczane do konstruktorów atrybutu jako parametry pozycyjne. Dla każdego obowiązkowego argumentu atrybut powinien również dostarczyć odpowiadającą właściwość tylko do odczytu, dzięki której można pobrać wartość argumentu w czasie wykonywania. Atrybuty mogą też definiować argumenty opcjonalne, które są znane również jako argumenty nazwane. Argumenty te są dostarczane do konstruktorów atrybutu poprzez nazwę i powinny mieć odpowiadającą właściwość umożliwiającą odczyt i zapis. |
| [CA1020: Unikaj przestrzeni nazw z kilkoma typami](../code-quality/ca1020.md) | Upewnij się, że każda przestrzeń nazw ma logiczną organizację i że masz ważną przyczynę umieszczenia typów w rozrzedzonie wypełnionym obszarze nazw. |
| [CA1021: Unikanie parametrów wyjściowych](../code-quality/ca1021.md) | Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi. Ponadto różnica między parametrami out i ref nie jest powszechnie zrozumiała. |
| [CA1023: Indeksatory nie powinny być wielowymiarowe](../code-quality/ca1023.md) | Indeksatory (właściwości indeksowane) powinny używać pojedynczego indeksu. Indeksatory wielowymiarowe mogą znacznie zmniejszyć użyteczność biblioteki. |
| [CA1024: Używaj właściwości wszędzie, gdzie jest to odpowiednie](../code-quality/ca1024.md) | Metody publiczne lub chronione mają nazwę zaczynającą się od „Get”, nie posiadają parametrów i zwracają wartość, która nie jest tablicą. Metoda ta może być dobrym kandydatem na właściwość. |
| [CA1025: Zastąp powtarzające się argumenty tablicą parametrów](../code-quality/ca1025.md) | Użyj tablicy parametrów zamiast powtarzających się argumentów, gdy znana jest dokładna liczba argumentów i argumenty zmiennych są tego samego typu lub mogą być przekazane jako ten sam typ. |
| [CA1026: Nie należy używać parametrów domyślnych](../code-quality/ca1026.md) | Metody z wykorzystaniem parametrów domyślnych są dozwolone w ramach CLS, jednak CLS umożliwia kompilatorom ignorowanie wartości, które są przypisane do tych parametrów. Aby zapewnić odpowiednie zachowanie w językach programowania, metody z wykorzystaniem parametrów domyślnych należy zastąpić przeciążeniami metody, które dostarczają parametry domyślne. |
| [CA1027: Oznaczaj wyliczenia za pomocą FlagsAttribute](../code-quality/ca1027.md) | Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych. Zastosuj atrybut FlagsAttribute do wyliczenia, gdy jego stałe nazwane mogą zostać sensownie połączone. |
| [CA1028: Magazyn typu wyliczeniowego powinien być typu Int32](../code-quality/ca1028.md) | Wyliczenie to typ wartości, który definiuje zestaw powiązanych, nazwanych stałych. Domyślnie typ danych System.Int32 jest używany do przechowywania wartości stałej. Mimo że można zmienić ten typ podstawowy, nie jest to wymagane ani zalecane w przypadku większości scenariuszy. |
| [CA1030: Używaj zdarzeń wszędzie, gdzie jest to odpowiednie](../code-quality/ca1030.md) | Ta reguła wykrywa metody o nazwach, które normalnie mogą być używane dla zdarzeń. Jeśli metoda jest wywoływana w odpowiedzi na jasno określoną zmianę stanu, powinna ona zostać wywołana przez program obsługi zdarzeń. Obiekty, które wywołują tę metodę, powinny wywoływać zdarzenia, a nie bezpośrednio metodę. |
| [CA1031: Nie przechwytuj wyjątków typów ogólnych](../code-quality/ca1031.md) | Ogólne wyjątki nie powinny być przechwytywane. Przechwyć wyjątek bardziej szczegółowy lub ponownie Zgłoś wyjątek ogólny jako ostatnią instrukcję w bloku catch. |
| [CA1032: Implementowanie standardowych konstruktorów wyjątków](../code-quality/ca1032.md) | Niepowodzenie podczas dostarczenia pełnego zestawu konstruktorów może utrudnić poprawną obsługę wyjątków. |
| [CA1033: Typy podrzędne powinny móc wywoływać metody interfejsu](../code-quality/ca1033.md) | Niezapieczętowany typ widoczny na zewnątrz zapewnia jawną implementację metody interfejsu publicznego i nie dostarcza alternatywnej metody widocznej z zewnątrz o tej samej nazwie. |
| [CA1034: Typy zagnieżdżone nie powinny być widoczne](../code-quality/ca1034.md) | Typ zagnieżdżony to typ, który jest zadeklarowany wewnątrz zakresu innego typu. Typy zagnieżdżone są przydatne w przypadku hermetyzacji szczegółów implementacji prywatnej typu zawierającego. Używane w tym celu typy zagnieżdżone nie powinny być widoczne na zewnątrz. |
| [CA1035: Implementacje interfejsu ICollection mają silnie typizowane składowe](../code-quality/ca1035.md) | Ta reguła wymaga implementacji ICollection w celu dostarczenia mocno typizowanych elementów członkowskich, tak aby użytkownicy nie musieli rzutować argumentów na typ Object w przypadku używania funkcjonalności dostarczonej przez interfejs. Ta reguła zakłada, że typ, który implementuje ICollection, robi to tak, aby zarządzać kolekcją wystąpień typów mocniejszych niż Object. |
| [CA1036: Przesłoń metody dla typów obsługujących porównywanie](../code-quality/ca1036.md) | Typ publiczny lub chroniony implementuje interfejs System.IComparable. Nie zastępuje on metody Object.Equals ani nie przeciąża specyficznego dla języka operatora równości, nierówności, mniejsze lub większe niż. |
| [CA1038: Moduły wyliczające powinny być silnie typizowane](../code-quality/ca1038.md) | Ta reguła wymaga implementacji IEnumerator w celu dostarczenia silnie typizowanej wersji właściwości Current, tak aby użytkownicy nie musieli rzutować wartości zwróconej na typ silny w przypadku używania funkcjonalności dostarczonej przez interfejs. |
| [CA1039: Listy są silnie typizowane](../code-quality/ca1039.md) | Ta reguła wymaga implementacji IList w celu dostarczenia silnie typizowanych elementów członkowskich, tak aby użytkownicy nie musieli rzutować argumentów na typ System.Object w przypadku używania funkcjonalności dostarczonej przez interfejs. |
| [CA1040: Unikaj pustych interfejsów](../code-quality/ca1040.md) | Interfejsy definiują elementy członkowskie, które zapewniają zachowanie lub użycie kontraktu. Funkcjonalność opisana przez interfejs może zostać przyjęta przez dowolny typ, niezależnie od tego, gdzie ten typ się pojawia w hierarchii dziedziczenia. Typ implementuje interfejs, dostarczając implementacje dla jego elementów członkowskich. Pusty interfejs nie definiuje żadnych elementów członkowskich; dlatego też nie definiuje kontraktu, który można zaimplementować. |
| [CA1041: Określ komunikat ObsoleteAttribute](../code-quality/ca1041.md) | Typ lub element członkowski jest oznaczony za pomocą atrybutu System.ObsoleteAttribute, który nie ma określonej właściwości ObsoleteAttribute.Message. Gdy jest kompilowany typ lub element członkowski, który jest oznaczony za pomocą ObsoleteAttribute, zostanie wyświetlona Właściwość Message dla atrybutu, który zawiera informacje o użytkowniku o nieaktualnym typie lub członku. |
| [CA1043: Dla indeksatorów używaj argumentów integral lub string](../code-quality/ca1043.md) | Indeksatory (właściwości indeksowane) powinny używać dla indeksu typów całkowitych lub ciągu. Typy te są zwykle używane do indeksowania struktur danych i zwiększają one użyteczność biblioteki. Użycie typu Object powinno zostać ograniczone do przypadków, w których nie może zostać określony typ całkowity lub ciąg w czasie projektowania. |
| [CA1044: Właściwości nie powinny być tylko do zapisu](../code-quality/ca1044.md) | Chociaż posiadanie właściwości tylko do odczytu jest dopuszczalne i często konieczne, wytyczne projektowania zabraniają używania właściwości tylko do zapisu. Dzieje się tak dlatego, że umożliwienie użytkownikowi ustawienia wartości, a następnie uniemożliwianie przeglądania tej wartości nie zapewnia żadnych zabezpieczeń. Poza tym bez dostępu do odczytu nie można przeglądać stanu obiektów udostępnionych, co ogranicza ich przydatność. |
| [CA1045: Nie przekazuj typów przez odwołanie](../code-quality/ca1045.md) | Przekazywanie typów przez odwołanie (używając out lub ref) wymaga doświadczenia w zakresie wskaźników, rozumienia różnicy między typami wartości i typami odwołania oraz umiejętności obsługi metod z wieloma wartościami zwracanymi. Architekci biblioteki, którzy tworzą dla wszystkich, nie powinni oczekiwać od użytkowników dobrej znajomości parametrów out lub ref. |
| [CA1046: Nie przeciążaj operatora równości w typach referencyjnych](../code-quality/ca1046.md) | Dla typów odwołań domyślna implementacja operatora równości jest prawie zawsze poprawna. Domyślnie dwa odwołania są równe tylko wtedy, gdy wskazują ten sam obiekt. |
| [CA1047: Nie deklaruj chronionych elementów członkowskich w typach zapieczętowanych](../code-quality/ca1047.md) | Chronione elementy członkowskie są zadeklarowane w typach tak, aby typy dziedziczące miały dostęp do elementu członkowskiego i mogły go zastąpić. Z definicji po typach zapieczętowanych nie można dziedziczyć, co oznacza, że nie można wywołać metody chronionej na typach zapieczętowanych. |
| [CA1048: Nie deklaruj wirtualnych elementów członkowskich w typach zapieczętowanych](../code-quality/ca1048.md) | Metody wirtualne są zadeklarowane w typach tak, aby typy dziedziczące mogły zmieniać implementację metod wirtualnych. Z definicji po typie zapieczętowanym nie można dziedziczyć. Powoduje to, że metoda wirtualna w typie zapieczętowanym jest całkowicie nieprzydatna. |
| [CA1049: Typy z zasobami natywnymi powinny być możliwe do likwidacji](../code-quality/ca1049.md) | Typy, które przydzielają zasoby niezarządzane, powinny implementować interfejs IDisposable, umożliwiając metodom wywołującym zwalnianie tych zasobów na żądanie i skrócenie czasu istnienia obiektów, które zawierają te zasoby. |
| [CA1050: Deklaruj typy w przestrzeniach nazw](../code-quality/ca1050.md) | Typy są zadeklarowane w przestrzeniach nazw, aby zapobiec kolizjom nazw oraz jako sposób organizowania typów powiązanych w hierarchii obiektów. |
| [CA1051: Nie deklaruj widocznych pól wystąpienia](../code-quality/ca1051.md) | Głównym zastosowaniem pola powinno być to, co szczegółowo opisuje implementacja. Pola powinny być prywatne lub wewnętrzne i dostępne przy użyciu właściwości. |
| [CA1052: Statyczne typy przechowujące powinny być zapieczętowane](../code-quality/ca1052.md) | Typ publiczny lub chroniony zawiera tylko statyczne elementy członkowskie i nie jest deklarowany za pomocą modyfikatora sealed (C#) lub NotInheritable (Visual Basic). Typ, po którym nie będzie dziedziczenia, powinien być oznakowany przy użyciu modyfikatora sealed, aby zapobiec użyciu go jako typu podstawowego. |
| [CA1053: Typy obsługi statycznej nie powinny mieć konstruktorów](../code-quality/ca1053.md) | Typ publiczny lub publiczny zagnieżdżony deklaruje tylko statyczne elementy członkowskie i ma publiczny lub chroniony konstruktor domyślny. Konstruktor jest zbędny, ponieważ wywołanie statycznego elementu członkowskiego nie wymaga wystąpienia tego typu. Przeciążenie typu ciąg powinno wywoływać, dla bezpieczeństwa, przeciążenie jednolitego identyfikatora zasobów (URI) przy użyciu argumentu typu ciąg. |
| [CA1054: Parametry identyfikatora URI nie powinny być ciągami](../code-quality/ca1054.md) | Jeśli metoda pobiera reprezentację ciągu identyfikatora URI, powinno zostać dostarczone odpowiadające przeciążenie, pobierające wystąpienie klasy URI, które dostarcza te usługi w bezpieczny sposób. |
| [CA1055: Wartości zwracane identyfikatora URI nie powinny być ciągami](../code-quality/ca1055.md) | Reguła ta zakłada, że metoda zwraca identyfikator URI. Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób. |
| [CA1056: Właściwości identyfikatora URI nie powinny być ciągami](../code-quality/ca1056.md) | Ta reguła zakłada, że właściwość reprezentuje identyfikator URI. Reprezentacja ciągu identyfikatora URI jest podatna na analizowanie i kodowanie błędów i może prowadzić do powstawania luk w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób. |
| [CA1057: Przeciążenia identyfikatora URI w postaci ciągu wywołują przeciążenia metody System.Uri](../code-quality/ca1057.md) | Typ deklaruje przeciążenia metody, które różnią się jedynie zastąpieniem parametru typu ciąg parametrem System.Uri. Przeciążenie, które przyjmuje parametr typu ciąg, nie wywołuje przeciążenia, które przyjmuje parametr identyfikatora URI. |
| [CA1058: Typy nie powinny rozszerzać pewnych typów bazowych](../code-quality/ca1058.md) | Typ widoczny na zewnątrz rozszerza niektóre typy podstawowe. Użyj jednej z alternatyw. |
| [CA1059: Składowe nie powinny ujawniać pewnych typów konkretnych](../code-quality/ca1059.md) | Konkretny typ jest typem posiadającym pełną implementację i dlatego może zostać utworzone jego wystąpienie. Aby włączyć powszechne użycie elementu członkowskiego, zamień konkretny typ, używając sugerowanego interfejsu. |
| [CA1060: Przenieś P/Invokes do klasy NativeMethods](../code-quality/ca1060.md) | Metody wywołania platformy, takie jak te oznaczone przy użyciu metody <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> lub i zdefiniowane za pomocą słowa kluczowego Declare [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]w, uzyskują dostęp do niezarządzanego kodu. Metody te powinny być klasami NativeMethods, SafeNativeMethods lub UnsafeNativeMethods. |
| [CA1061: Nie należy ukrywać metod klasy bazowej](../code-quality/ca1061.md) | Metoda w typie podstawowym jest ukryta przez metodę o identycznej nazwie typu pochodnego, gdy sygnatura parametru metody pochodnej różni się tylko typami, które są słabiej dziedziczone niż odpowiadające typy w sygnaturze parametru metody podstawowej. |
| [CA1062 Walidacja argumentów metod publicznych](../code-quality/ca1062.md) | Wszystkie argumenty odwołania, które są przekazywane do metody widocznej na zewnątrz, powinny być sprawdzane pod kątem wartości null. |
| [CA1063: Należy prawidłowo zaimplementować interfejs IDisposable](../code-quality/ca1063.md) | Wszystkie typy IDisposable powinny poprawnie implementować wzorzec Dispose. |
| [CA1064: Wyjątki powinny być publiczne](../code-quality/ca1064.md) | Wyjątek wewnętrzny jest widoczny tylko wewnątrz własnego zakresu wewnętrznego. W przypadku wystąpienia wyjątku poza zakresem wewnętrznym tylko wyjątek podstawowy może zostać użyty do jego przechwycenia. Jeśli wewnętrzny wyjątek jest Dziedziczony z <xref:System.Exception?displayProperty=fullName>,, <xref:System.SystemException?displayProperty=fullName>lub <xref:System.ApplicationException?displayProperty=fullName>, kod zewnętrzny nie będzie zawierał wystarczających informacji, aby dowiedzieć się, co należy zrobić z wyjątkiem. |
| [CA1065: Nie zgłaszaj wyjątków w nieoczekiwanych lokalizacjach](../code-quality/ca1065.md) | Metoda, od której nie oczekiwano zgłaszania wyjątków, zgłasza wyjątek. |
| [CA1066: Zaimplementuj IEquatable przy zastępowaniu Equals](../code-quality/ca1066.md) | Typ wartości przesłania <xref:System.Object.Equals%2A> metodę, ale nie implementuje <xref:System.IEquatable%601>. |
| [CA1067: Zastąp wartość Equals podczas implementowania IEquatable](../code-quality/ca1067.md) | Typ implementuje <xref:System.IEquatable%601>, ale nie przesłania <xref:System.Object.Equals%2A> metody. |
| [CA1068: parametry CancellationToken muszą pochodzić z ostatnich](../code-quality/ca1068.md) | Metoda ma parametr CancellationToken, który nie jest ostatnim parametrem. |
| [CA2210: Zestawy powinny mieć prawidłowe silne nazwy](../code-quality/ca2210.md) | Silna nazwa chroni klientów przed nieświadomym ładowaniem zestawu, który został zmieniony. Zestawy bez silnej nazwy nie powinny być wdrażane poza bardzo ograniczonymi scenariuszami. Jeśli użytkownik udostępnia lub dystrybuuje zestawy, które nie są poprawnie podpisane, zestaw może zostać zmieniony, środowisko uruchomieniowe języka wspólnego może nie załadować zestawu lub użytkownik będzie musiał wyłączyć weryfikację na swoim komputerze. |
