---
title: C26411
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f5b32327ad74d89b5351cbdaaa4efeebb7ec3379
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62572083"
---
# <a name="c26411--noreftouniqueptr"></a>C26411  NO_REF_TO_UNIQUE_PTR

Przekazywanie unikatowego wskaźnika poprzez odwołanie przyjęto założenie, że jego zasób może zostać wydane lub przeniesione wewnątrz docelowej funkcji. Jeśli funkcja używa jako parametr tylko dostępu do zasobu, jest bezpiecznie przekazać surowego wskaźnika lub odwołania.

## <a name="remarks"></a>Uwagi

- Ograniczenia z ostrzeżenie [C26410](C26410.md) stosuje się tu również.

- Heurystyki do wykrywania, "release" lub "Resetuj" dostęp do unikatowego wskaźnika jest raczej naiwni: wykryliśmy tylko wywołania operatory przypisania i funkcji o nazwie "Resetuj" (bez uwzględniania wielkości liter). Oczywiście to wykrywanie nie obejmują wszystkich możliwych przypadków inteligentny wskaźnik zmian (na przykład std::swap lub specjalnych funkcji niestały w niestandardowych inteligentnego wskaźnika). Oczekuje się, że to ostrzeżenie generuje wiele fałszywych alarmów, niestandardowe typy, a także w niektórych scenariuszach dotyczących standardowych wskaźników unikatowy. Zostanie on ulepszony heurystyki, jak wdrażamy sprawdzeń koncentruje się na inteligentnych wskaźników.

- Fakt, że inteligentne wskaźniki są często szablony oferuje interesujące ograniczenia związane z faktu, że kompilator nie jest wymagane do przetwarzania kodu szablonu w szablonach, jeśli nie jest używany. W niektórych bazach minimalnej ilości kodu, które ma ograniczone użycie interfejsów inteligentny wskaźnik moduł sprawdzania może dać nieoczekiwane wyniki z powodu jego brakiem, aby prawidłowo identyfikować semantyki typ szablonu (ponieważ nigdy nie może być stosowane na niektórych ważnych funkcji). Standardu `unique_pointer`, to ograniczenie jest zmniejszany przez rozpoznawanie nazwy typu. To może należy rozszerzyć w przyszłości bardziej dobrze znanych inteligentnych wskaźników.

- Wyrażenia lambda z niejawne przechwytywania by-reference może prowadzić do Zaskakujące ostrzeżenia dotyczące odwołania do wskaźników unikatowy. Obecnie wszystkie parametry przechwyconych odwołań w wyrażeniach lambda są zgłaszane, niezależnie od tego, czy są one resetowane czy nie. Algorytm heurystyczny w tym miejscu zostanie rozszerzone w taki sposób, aby skorelować pola lambda z parametrów wyrażenia lambda w przyszłej wersji.

## <a name="example-unnecessary-reference"></a>Przykład: Niepotrzebne odniesienia

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```