---
title: CA1062 Walidacja argumentów metod publicznych
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
- Validate arguments of public methods
helpviewer_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 80e3d1d6a6c9db3912048aee9c282ec5f105a121
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/01/2020
ms.locfileid: "75580724"
---
# <a name="ca1062-validate-arguments-of-public-methods"></a>CA1062 Walidacja argumentów metod publicznych

|||
|-|-|
|TypeName|ValidateArgumentsOfPublicMethods|
|CheckId|CA1062|
|Kategoria|Microsoft.Design|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna

Widoczna na zewnątrz Metoda odwołuje się do jednego z argumentów odwołania bez weryfikowania, czy ten argument jest `null` (`Nothing` w Visual Basic).

Następujące aspekty tej reguły [można konfigurować](#configurability):
* Określa, czy należy analizować metodę rozszerzenia "This".
* Określ metody sprawdzania poprawności sprawdzenia wartości null w przywoływanych bibliotekach lub projektach, które sprawdzają, czy argumenty przekazane do niego są inne niż null.
* Części bazy kodu do wykluczenia z analizy.

## <a name="rule-description"></a>Opis reguły

Wszystkie argumenty odwołania, które są przekazane do widocznych zewnętrznie metod, powinny być sprawdzane pod względem `null`. W razie potrzeby Zgłoś <xref:System.ArgumentNullException>, gdy argument jest `null`.

Jeśli metodę można wywołać z nieznanego zestawu, ponieważ jest ona zadeklarowana jako publiczna lub chroniona, należy zweryfikować wszystkie parametry metody. Jeśli metoda jest przeznaczona do wywoływania tylko przez znane zestawy, należy wprowadzić metodę wewnętrzną i zastosować <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybutu do zestawu, który zawiera metodę.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, sprawdź poprawność każdego argumentu odwołania względem `null`.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

Możesz pominąć ostrzeżenie z tej reguły, jeśli masz pewność, że odwołanie do parametru zostało zweryfikowane przez inne wywołanie metody w funkcji.

## <a name="configurability"></a>Określając

Jeśli uruchamiasz tę regułę z [analizatorów FxCop](install-fxcop-analyzers.md) (a nie ze starszą analizą), możesz skonfigurować analizę dla tej reguły.

### <a name="exclude-extension-method-this-parameter"></a>Wyklucz metodę rozszerzenia "This"

Domyślnie ta reguła analizuje i flaguje parametr `this` dla metod rozszerzających. Można wykluczyć analizę `this` parametru dla metod rozszerzających, dodając następującą parę klucz-wartość do pliku. editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.exclude_extension_method_this_parameter = true
```

### <a name="null-check-validation-methods"></a>Metody sprawdzania poprawności sprawdzania wartości null

Ta reguła może prowadzić do fałszywych wartości dodatnich, jeśli kod wywołuje specjalne metody sprawdzania poprawności sprawdzania wartości null w przywoływanych bibliotekach lub projektach. Można uniknąć tych fałszywych wartości dodatnich przez określenie nazwy lub sygnatury metod sprawdzania poprawności sprawdzenia wartości null.  Następnie analiza przyjmie, że argumenty przekazane do tej metody są inne niż null po wywołaniu. Na przykład aby oznaczyć wszystkie metody o nazwie `Validate` jako metody sprawdzania poprawności sprawdzenia wartości null, można dodać następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.null_check_validation_methods = Validate
```

Dozwolone formaty nazw metod w wartości opcji (oddzielone znakiem "|"):
  - Tylko nazwa metody (zawiera wszystkie metody o nazwie, niezależnie od typu zawierającego lub przestrzeni nazw)
  - W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu z opcjonalnym prefiksem `M:`.

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate` | Dopasowuje wszystkie metody o nazwie "Validate" w kompilacji
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate1|Validate2` | Dopasowuje wszystkie metody o nazwie "Validate1" lub "Validate2" w kompilacji
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS.MyType.Validate(ParamType)` | Dopasowuje określoną metodę "Validate" przy użyciu podanego w pełni kwalifikowanego podpisu
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS1.MyType1.Validate1(ParamType)|NS2.MyType2.Validate2(ParamType)` | Dopasowuje określone metody "Validate1" i "Validate2" z odpowiednimi w pełni kwalifikowanymi sygnaturami

### <a name="excluded-symbol-names"></a>Wykluczone nazwy symboli

Można skonfigurować, które części bazy kodu mają być wykluczone z analizy. Na przykład, aby określić, że reguła nie powinna być uruchamiana na żadnym kodzie w typach o nazwie `MyType`, Dodaj następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.excluded_symbol_names = MyType
```

Dozwolone formaty nazw symboli w wartości opcji (oddzielone znakiem "|"):
  - Tylko nazwa symbolu (zawiera wszystkie symbole z nazwą, niezależnie od typu zawierającego lub przestrzeni nazw)
  - W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu. Każda nazwa symbolu wymaga prefiksu rodzaju symboli, takiego jak "M:" prefix dla metod, "T:" prefiksu dla typów, "N:" prefiksu dla przestrzeni nazw itd.
  - `.ctor` dla konstruktorów i `.cctor` dla konstruktorów statycznych

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType` | Dopasowuje wszystkie symbole o nazwie "MyType" w kompilacji
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType1|MyType2` | Dopasowuje wszystkie symbole o nazwie "MyType1" lub "MyType2" w kompilacji
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Dopasowuje określoną metodę "nomethod" przy użyciu podanego w pełni kwalifikowanego podpisu
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Dopasowuje określone metody "MyMethod1" i "MyMethod2" z odpowiednimi w pełni kwalifikowanymi sygnaturami

Wszystkie te opcje można skonfigurować dla opcji tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (projekt). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Przykład

Poniższy przykład pokazuje metodę, która narusza regułę i metodę, która spełnia kryteria.

```csharp
using System;

namespace DesignLibrary
{
    public class Test
    {
        // This method violates the rule.
        public void DoNotValidate(string input)
        {
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }

        // This method satisfies the rule.
        public void Validate(string input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }
    }
}
```

```vb
Imports System

Namespace DesignLibrary

    Public Class Test

        ' This method violates the rule.
        Sub DoNotValidate(ByVal input As String)

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

        ' This method satisfies the rule.
        Sub Validate(ByVal input As String)

            If input Is Nothing Then
                Throw New ArgumentNullException(NameOf(input))
            End If

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

    End Class

End Namespace
```

## <a name="example"></a>Przykład

Konstruktory kopiujące wypełniające pola lub właściwości, które są obiektami odniesienia, mogą również naruszać regułę CA1062. Naruszenie występuje, ponieważ skopiowany obiekt, który jest przesyłany do konstruktora kopiującego, może być `null` (`Nothing` w Visual Basic). Aby rozwiązać ten problem, należy użyć statycznej metody udostępnionej w Visual Basic), aby sprawdzić, czy skopiowany obiekt nie ma wartości null.

W poniższym przykładzie klasy `Person`, obiekt `other`, który jest przesyłany do konstruktora `Person` Copy może być `null`.

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor CA1062 fires because other is dereferenced
    // without being checked for null
    public Person(Person other)
        : this(other.Name, other.Age)
    {
    }
}
```

## <a name="example"></a>Przykład

W poniższym przykładzie zmienionym `Person` obiekt `other`, który jest przesyłany do konstruktora kopiującego, jest najpierw sprawdzany pod kątem wartości null w metodzie `PassThroughNonNull`.

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor
    public Person(Person other)
        : this(PassThroughNonNull(other).Name, other.Age)
    {
    }

    // Null check method
    private static Person PassThroughNonNull(Person person)
    {
        if (person == null)
            throw new ArgumentNullException(nameof(person));
        return person;
    }
}
```
