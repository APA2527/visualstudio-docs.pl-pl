---
title: C26117
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C26117
helpviewer_keywords:
- C26117
ms.assetid: cc7ebc8d-9826-4cad-a4d5-2d3ad5896734
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: e1ade9409a24b18472ecef088d3ebab6ababd6e3
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62550165"
---
# <a name="c26117"></a>C26117
Ostrzeżenie C26117: Zwalnianie nie utrzymywanej blokady \<blokada > w funkcji \<func >.

 Wymuszanie składniowo zakresie blokady *uzyskania* i blokadę przy użyciu *wersji* pary w programów C/C++ nie jest wykonywane przez język. Funkcja może powodować blokowanie efekt uboczny, wprowadzając dostrzegalnych modyfikacji stanu współbieżności. Na przykład funkcji otoku blokady zwiększa liczbę nabycia blokady lub liczbę blokad, dla danej blokady. Możesz dodawać adnotacje do funkcji, która ma efekt z blokadą nabycia lub zablokować wydania przy użyciu `_Acquires_lock_` lub `_Releases_lock_`, odpowiednio. Bez tych adnotacji funkcji oczekuje się, nie należy zmieniać dowolnej liczbie blokady po zwraca. Jeśli uzyskuje i wersje nie są równoważone, są traktowane jako *oddzielone*. Ostrzeżenie C26117 wystawiono, gdy funkcja, która nie ma zostać oznaczony za pomocą `_Releases_lock_` zwalnia blokadę, który go nie ma on, ponieważ funkcja musi być właścicielem blokady przed jej do wydania.

## <a name="example"></a>Przykład
 Poniższy przykład generuje ostrzeżenie C26117, ponieważ funkcja `ReleaseUnheldLock` zwalnia blokadę, który nie musi przechowywać — stan `flag` jest niejednoznaczne — i nie ma żadnych adnotacji, określający, że należy.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
        EnterCriticalSection(&p->cs);
    // code ...
    LeaveCriticalSection(&p->cs);
}
```

## <a name="example"></a>Przykład
 Poniższy kod naprawia problem, gwarantując, że wydane jest również blokada w tych samych warunkach.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
    {
        EnterCriticalSection(&p->cs);
        // code ...
        LeaveCriticalSection(&p->cs);
    }
}
```

## <a name="see-also"></a>Zobacz też

- [C26115](../code-quality/c26115.md)