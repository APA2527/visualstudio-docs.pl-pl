---
title: 'CA2115: Wywołaj GC.KeepAlive gdy używasz zasobów natywnych'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CallGCKeepAliveWhenUsingNativeResources
- CA2115
helpviewer_keywords:
- CA2115
- CallGCKeepAliveWhenUsingNativeResources
ms.assetid: f00a59a7-2c6a-4bbe-a1b3-7bf77d366f34
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- cplusplus
ms.openlocfilehash: 2bc584c2acf7fe49c68fe13c6e219e2e0cd771b3
ms.sourcegitcommit: 1efb6b219ade7c35068b79fbdc573a8771ac608d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/28/2020
ms.locfileid: "78168849"
---
# <a name="ca2115-call-gckeepalive-when-using-native-resources"></a>CA2115: Wywołaj GC.KeepAlive gdy używasz zasobów natywnych

|||
|-|-|
|TypeName|CallGCKeepAliveWhenUsingNativeResources|
|CheckId|CA2115|
|Kategoria|Microsoft.Security|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna
Metoda zadeklarowana w typie z finalizatorem odwołuje się do <xref:System.IntPtr?displayProperty=fullName> lub <xref:System.UIntPtr?displayProperty=fullName> pola, ale nie wywołuje <xref:System.GC.KeepAlive%2A?displayProperty=fullName>.

> [!NOTE]
> Ta starsza reguła nie jest dostępna w analizatorach FxCop. Aby uzyskać więcej informacji, zobacz [reguły przestarzałe](fxcop-rule-port-status.md#deprecated-rules).

## <a name="rule-description"></a>Opis reguły

Wyrzucanie elementów bezużytecznych kończy obiekt, jeśli nie ma więcej odwołań do niego w kodzie zarządzanym. Niezarządzane odwołania do obiektów nie uniemożliwiają wyrzucania elementów bezużytecznych. Ta reguła wykrywa błędy, które mogą wystąpić, ponieważ kończy się działanie niezarządzanego zasobu, a wciąż jest on używany w kodzie niezarządzanym.

Ta reguła zakłada, że pola <xref:System.IntPtr> i <xref:System.UIntPtr> przechowują wskaźniki do zasobów niezarządzanych. Ponieważ celem finalizatora jest zwolnienie niezarządzanych zasobów, reguła zakłada, że finalizator spowoduje zwolnienie niezarządzanego zasobu wskazywanego przez pola wskaźnika. Ta reguła zakłada również, że metoda odwołuje się do pola wskaźnika, aby przekazać niezarządzany zasób do kodu niezarządzanego.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, Dodaj wywołanie do <xref:System.GC.KeepAlive%2A> metody, przekazując bieżące wystąpienie (`this` w C# i C++) jako argument. Umieść wywołanie po ostatnim wierszu kodu, w którym obiekt musi być chroniony przed wyrzucaniem elementów bezużytecznych. Natychmiast po wywołaniu <xref:System.GC.KeepAlive%2A>obiekt jest ponownie uznawany za gotowy do wyrzucania elementów bezużytecznych przy założeniu, że nie istnieją żadne zarządzane odwołania.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

Ta reguła wykonuje pewne założenia, które mogą prowadzić do fałszywych wartości dodatnich. Możesz bezpiecznie pominąć ostrzeżenie z tej reguły, jeśli:

- Finalizator nie zwalnia zawartości <xref:System.IntPtr> lub pola <xref:System.UIntPtr>, do którego odwołuje się metoda.

- Metoda nie przekazuje pola <xref:System.IntPtr> ani <xref:System.UIntPtr> do kodu niezarządzanego.

Uważnie Przejrzyj inne komunikaty przed wyłączeniem ich. Ta zasada wykrywa błędy, które są trudne do odtworzenia i debugowania.

## <a name="example"></a>Przykład

W poniższym przykładzie `BadMethod` nie zawiera wywołania do `GC.KeepAlive` i w związku z tym narusza zasady. `GoodMethod` zawiera skorygowany kod.

> [!NOTE]
> Ten przykład to pseudo-kod. Chociaż kod kompiluje i uruchamia, ostrzeżenie nie zostanie wyzwolone, ponieważ niezarządzany zasób nie został utworzony ani zwolniony.

[!code-csharp[FxCop.Security.IntptrAndFinalize#1](../code-quality/codesnippet/CSharp/ca2115-call-gc-keepalive-when-using-native-resources_1.cs)]

## <a name="see-also"></a>Zobacz też

- <xref:System.GC.KeepAlive%2A?displayProperty=fullName>
- <xref:System.IntPtr?displayProperty=fullName>
- <xref:System.Object.Finalize%2A?displayProperty=fullName>
- <xref:System.UIntPtr?displayProperty=fullName>
- [Wzorzec Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
