---
title: 'CA2115: Wywołaj GC.KeepAlive gdy używasz zasobów natywnych'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CallGCKeepAliveWhenUsingNativeResources
- CA2115
helpviewer_keywords:
- CA2115
- CallGCKeepAliveWhenUsingNativeResources
ms.assetid: f00a59a7-2c6a-4bbe-a1b3-7bf77d366f34
author: jillre
ms.author: mikejo
manager: jillfra
ms.workload:
- cplusplus
ms.openlocfilehash: d995ff7bd62e93b00aeb3177d711d1bde03a03aa
ms.sourcegitcommit: 00ba14d9c20224319a5e93dfc1e0d48d643a5fcd
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/08/2020
ms.locfileid: "77091395"
---
# <a name="ca2115-call-gckeepalive-when-using-native-resources"></a>CA2115: Wywołaj GC.KeepAlive gdy używasz zasobów natywnych

|||
|-|-|
|TypeName|CallGCKeepAliveWhenUsingNativeResources|
|CheckId|CA2115|
|Kategoria|Microsoft.Security|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna
Metoda zadeklarowana w typie z finalizatorem odwołuje się do <xref:System.IntPtr?displayProperty=fullName> lub <xref:System.UIntPtr?displayProperty=fullName> pola, ale nie wywołuje <xref:System.GC.KeepAlive%2A?displayProperty=fullName>.

> [!NOTE]
> Ta starsza reguła nie jest dostępna w analizatorach FxCop. Aby uzyskać więcej informacji, zobacz [reguły przestarzałe](fxcop-rule-port-status.md#deprecated-rules).

## <a name="rule-description"></a>Opis reguły

Wyrzucanie elementów bezużytecznych kończy obiekt, jeśli nie ma więcej odwołań do niego w kodzie zarządzanym. Niezarządzane odwołania do obiektów nie uniemożliwiają wyrzucania elementów bezużytecznych. Ta reguła wykrywa błędy, które mogą wystąpić, ponieważ kończy się działanie niezarządzanego zasobu, a wciąż jest on używany w kodzie niezarządzanym.

Ta reguła zakłada, że pola <xref:System.IntPtr> i <xref:System.UIntPtr> przechowują wskaźniki do zasobów niezarządzanych. Ponieważ celem finalizatora jest zwolnienie niezarządzanych zasobów, reguła zakłada, że finalizator spowoduje zwolnienie niezarządzanego zasobu wskazywanego przez pola wskaźnika. Ta reguła zakłada również, że metoda odwołuje się do pola wskaźnika, aby przekazać niezarządzany zasób do kodu niezarządzanego.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, Dodaj wywołanie do <xref:System.GC.KeepAlive%2A> metody, przekazując bieżące wystąpienie (`this` w C# i C++) jako argument. Umieść wywołanie po ostatnim wierszu kodu, w którym obiekt musi być chroniony przed wyrzucaniem elementów bezużytecznych. Natychmiast po wywołaniu <xref:System.GC.KeepAlive%2A>obiekt jest ponownie uznawany za gotowy do wyrzucania elementów bezużytecznych przy założeniu, że nie istnieją żadne zarządzane odwołania.

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

Ta reguła wykonuje pewne założenia, które mogą prowadzić do fałszywych wartości dodatnich. Możesz bezpiecznie pominąć ostrzeżenie z tej reguły, jeśli:

- Finalizator nie zwalnia zawartości <xref:System.IntPtr> lub pola <xref:System.UIntPtr>, do którego odwołuje się metoda.

- Metoda nie przekazuje pola <xref:System.IntPtr> ani <xref:System.UIntPtr> do kodu niezarządzanego.

Uważnie Przejrzyj inne komunikaty przed wyłączeniem ich. Ta zasada wykrywa błędy, które są trudne do odtworzenia i debugowania.

## <a name="example"></a>Przykład

W poniższym przykładzie `BadMethod` nie zawiera wywołania do `GC.KeepAlive` i w związku z tym narusza zasady. `GoodMethod` zawiera skorygowany kod.

> [!NOTE]
> Ten przykład to pseudo-kod. Chociaż kod kompiluje i uruchamia, ostrzeżenie nie zostanie wyzwolone, ponieważ niezarządzany zasób nie został utworzony ani zwolniony.

[!code-csharp[FxCop.Security.IntptrAndFinalize#1](../code-quality/codesnippet/CSharp/ca2115-call-gc-keepalive-when-using-native-resources_1.cs)]

## <a name="see-also"></a>Zobacz także

- <xref:System.GC.KeepAlive%2A?displayProperty=fullName>
- <xref:System.IntPtr?displayProperty=fullName>
- <xref:System.Object.Finalize%2A?displayProperty=fullName>
- <xref:System.UIntPtr?displayProperty=fullName>
- [Wzorzec Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
