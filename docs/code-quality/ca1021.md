---
title: 'CA1021: Unikanie parametrów wyjściowych'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 579b04f26af972ac025b0bfc07bc8dc9eb636d12
ms.sourcegitcommit: 98421670ed0b8170aaa32d3d6f8681298f401a1d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/18/2020
ms.locfileid: "81638033"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021: Unikanie parametrów wyjściowych

|||
|-|-|
|TypeName|AvoidOutParameters|
|CheckId|CA1021|
|Kategoria|Microsoft.Design|
|Przełomowa zmiana|Kluczowa|

## <a name="cause"></a>Przyczyna
Metoda publiczna lub chroniona w `out` typie publicznym ma parametr.

Domyślnie ta reguła dotyczy tylko typów widocznych z zewnątrz, ale jest [konfigurowalna](#configurability).

## <a name="rule-description"></a>Opis reguły
Przekazywanie typów przez `out` `ref`odwołanie (przy użyciu lub ) wymaga doświadczenia ze wskaźnikami, zrozumienie, jak różnią się typy wartości i typy odwołań i metody obsługi z wieloma wartościami zwracanymi. Ponadto różnica między `out` `ref` i parametry nie jest szeroko rozumiana.

Gdy typ odwołania jest przekazywany "przez odwołanie", metoda zamierza użyć parametru, aby zwrócić inne wystąpienie obiektu. Przekazywanie typu odwołania przez odwołanie jest również znany jako przy użyciu podwójnego wskaźnika, wskaźnik do wskaźnika lub dwukrotnie indirection. Za pomocą domyślnej konwencji wywoływania, który jest przekazywać "przez wartość", parametr, który przyjmuje typ odwołania już odbiera wskaźnik do obiektu. Wskaźnik, a nie obiekt, do którego wskazuje, jest przekazywany przez wartość. Przekazywanie przez wartość oznacza, że metoda nie można zmienić wskaźnik, aby go wskazać nowe wystąpienie typu odwołania. Można jednak zmienić zawartość obiektu, na który wskazuje. W przypadku większości aplikacji jest to wystarczające i daje pożądane zachowanie.

Jeśli metoda musi zwrócić inne wystąpienie, należy użyć zwracanej wartości metody, aby to osiągnąć. Zobacz <xref:System.String?displayProperty=fullName> klasy dla różnych metod, które działają na ciągi i zwraca nowe wystąpienie ciągu. Gdy ten model jest używany, obiekt wywołujący musi zdecydować, czy oryginalny obiekt jest zachowywany.

Chociaż wartości zwracane są powszechne i intensywnie `out` `ref` używane, prawidłowe stosowanie i parametry wymaga pośredniego projektowania i umiejętności kodowania. Architekci biblioteki, którzy projektują dla ogółu `ref` odbiorców, nie powinni oczekiwać, że użytkownicy będą opanować pracę lub `out` parametry.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia
Aby naprawić naruszenie tej reguły, która jest spowodowana przez typ wartości, należy zwrócić obiekt jako jego wartość zwracaną. Jeśli metoda musi zwrócić wiele wartości, przeprojektować go, aby zwrócić pojedyncze wystąpienie obiektu, który przechowuje wartości.

Aby naprawić naruszenie tej reguły, która jest spowodowana przez typ odwołania, upewnij się, że pożądane zachowanie jest zwrócenie nowego wystąpienia odwołania. Jeśli tak jest, metoda powinna używać jego zwracanej wartości, aby to zrobić.

## <a name="when-to-suppress-warnings"></a>Kiedy należy pomijać ostrzeżenia
Można bezpiecznie pominąć ostrzeżenie od tej reguły. Jednak ten projekt może powodować problemy z użytecznością.

## <a name="configurability"></a>Konfiguracji

Jeśli ta reguła jest uruchomiona z [analizatorów FxCop](install-fxcop-analyzers.md) (a nie z starszą analizą), możesz skonfigurować części bazy kodu, aby uruchomić tę regułę na podstawie ich ułatwień dostępu. Na przykład, aby określić, że reguła powinna być uruchamiana tylko na powierzchni niepublicznego interfejsu API, dodaj następującą parę klucz-wartość do pliku .editorconfig w projekcie:

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

Tę opcję można skonfigurować tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (Projekt). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Przykład
W poniższej bibliotece przedstawiono dwie implementacje klasy, która generuje odpowiedzi na opinie użytkownika. Pierwsza implementacja`BadRefAndOut`( ) wymusza użytkownika biblioteki do zarządzania trzema wartościami zwracania. Druga implementacja`RedesignedRefAndOut`( ) upraszcza środowisko użytkownika, zwracając wystąpienie klasy kontenera (`ReplyData`), która zarządza danymi jako pojedynczą jednostką.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>Przykład
Poniższa aplikacja ilustruje środowisko użytkownika. Wywołanie przeprojektowane biblioteki (`UseTheSimplifiedClass` metoda) jest bardziej proste, a informacje zwracane przez metodę jest łatwo zarządzane. Dane wyjściowe z dwóch metod jest identyczna.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>Przykład
Poniższa przykładowa biblioteka ilustruje, jak `ref` parametry dla typów odwołań są używane i pokazuje lepszy sposób zaimplementowania tej funkcji.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>Przykład
Następująca aplikacja wywołuje każdą metodę w bibliotece, aby zademonstrować zachowanie.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

Ten przykład generuje następujące wyniki:

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>Wypróbuj metody wzorca

### <a name="description"></a>Opis
Metody, które implementują **try\<something>** <xref:System.Int32.TryParse%2A?displayProperty=fullName>wzorzec, takich jak , nie podnieść tego naruszenia. Poniższy przykład przedstawia strukturę (typ wartości), która implementuje <xref:System.Int32.TryParse%2A?displayProperty=fullName> metodę.

### <a name="code"></a>Code
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>Powiązane reguły
[CA1045: Nie przekazuj typów przez odwołanie](../code-quality/ca1045.md)
