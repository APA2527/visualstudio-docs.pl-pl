---
title: C26111
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C26111
helpviewer_keywords:
- C26111
ms.assetid: 85fc740a-3bbb-41b8-a848-95e243a08da9
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 7550fb74ae5fb6e4a18ae2d7391dfca3cc0546f3
ms.sourcegitcommit: 485ffaedb1ade71490f11cf05962add1718945cc
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/16/2019
ms.locfileid: "72448577"
---
# <a name="c26111"></a>C26111
Ostrzeżenie C26111: wywołujący nie mógł zwolnić blokady \<lock > przed wywołaniem > funkcji @no__t 1func.

 Adnotacja `_Requires_lock_not_held_` nakłada warunek wstępny, że liczba blokad dla określonej blokady nie może być większa od zera, gdy funkcja jest wywoływana. Ostrzeżenie C26111 jest generowane, gdy funkcja nie może zwolnić blokady przed wywołaniem innej funkcji.

## <a name="example"></a>Przykład
 Poniższy przykład generuje ostrzeżenie C26111, ponieważ warunki wstępne @no__t 0 są naruszane przez wywołanie `DoNotLock` w zablokowanej sekcji.

```

typedef struct _DATA
{
    CRITICAL_SECTION cs;
    int d;
} DATA;

_Requires_lock_not_held_(p->cs)

void DoNotLock(DATA* p)
{
    EnterCriticalSection(&p->cs);
    p->d = 0;
    LeaveCriticalSection(&p->cs);
}

void LockedFunction(DATA* p)
{
    EnterCriticalSection(&p->cs);
    DoNotLock(p); // Warning C26111
    LeaveCriticalSection(&p->cs);
}
```
