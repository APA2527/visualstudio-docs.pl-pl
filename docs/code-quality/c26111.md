---
title: C26111
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C26111
helpviewer_keywords:
- C26111
ms.assetid: 85fc740a-3bbb-41b8-a848-95e243a08da9
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: a0e91d4d8fedae14a23ed118ab592fe0842a27e8
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2019
ms.locfileid: "72015673"
---
# <a name="c26111"></a>C26111
Ostrzeżenie C26111: Obiekt wywołujący nie może zwolnić blokady \<lock > przed wywołaniem funkcji \<func >.

 Adnotacja `_Requires_lock_not_held_` nakłada warunek wstępny, że liczba blokad dla określonej blokady nie może być większa od zera, gdy funkcja jest wywoływana. Ostrzeżenie C26111 jest generowane, gdy funkcja nie może zwolnić blokady przed wywołaniem innej funkcji.

## <a name="example"></a>Przykład
 Poniższy przykład generuje ostrzeżenie C26111, ponieważ warunki wstępne @no__t 0 są naruszane przez wywołanie `DoNotLock` w zablokowanej sekcji.

```

typedef struct _DATA
{
    CRITICAL_SECTION cs;
    int d;
} DATA;

_Requires_lock_not_held_(p->cs)

void DoNotLock(DATA* p)
{
    EnterCriticalSection(&p->cs);
    p->d = 0;
    LeaveCriticalSection(&p->cs);
}

void LockedFunction(DATA* p)
{
    EnterCriticalSection(&p->cs);
    DoNotLock(p); // Warning C26111
    LeaveCriticalSection(&p->cs);
}
```