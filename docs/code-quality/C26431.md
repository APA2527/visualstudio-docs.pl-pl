---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 029b3b076688f6aab4a70a9077b01ddd2ea35586
ms.sourcegitcommit: e98db44f3a33529b0ba188d24390efd09e548191
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/25/2019
ms.locfileid: "71253355"
---
# <a name="c26431-dont_test_notnull"></a>C26431 DONT_TEST_NOTNULL

"Typ wyrażenia jest już GSL:: NOT_NULL. Nie sprawdzaj go pod kątem wartości null ".

**C++ Podstawowe wytyczne**: F. 23: Użyj NOT_NULL\<T >, aby wskazać, że wartość "null" nie jest prawidłową wartością

Znacznik typu GSL:: NOT_NULL z biblioteki obsługi wytycznych służy do wyraźnego wskazywania wartości, które nigdy nie mają wskaźników null. Powoduje to powstanie twardego błędu, jeśli takie założenie nie jest przechowywane w czasie wykonywania. Oczywiście nie trzeba sprawdzać wartości null, jeśli wyrażenie zwróci wynik typu GSL:: NOT_NULL.

## <a name="remarks"></a>Uwagi

- Ponieważ GSL:: NOT_NULL jest klasą otoki o cienkim wskaźniku, reguła faktycznie śledzi zmienne tymczasowe, które przechowują wyniki wywołań do przeciążonego operatora konwersji (który zwraca zawarty obiekt wskaźnika). Taka logika powoduje, że ta reguła ma zastosowanie do wyrażeń, które obejmują zmienne i ostatecznie mają wynik typu GSL:: NOT_NULL. Ale obecnie pomija wyrażenia, które zawierają wywołania funkcji zwracających GSL:: NOT_NULL.
  - Bieżący algorytm heurystyczny dla kontroli wartości null wykrywa następujące konteksty:
  - wyrażenie symbolu w warunku rozgałęzienia, na przykład "if (p) {...}";
  - niebitowe operacje logiczne;
  - operacje porównania, w których jeden operand jest wyrażeniem stałym, którego wynikiem jest zero.

## <a name="example"></a>Przykład

niepotrzebne testy zerowe ujawniają logikę wątpliwą

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

niepotrzebne sprawdzenia wartości null ujawniają logikę wątpliwą — przedziały

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```
