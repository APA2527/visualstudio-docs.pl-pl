---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 72f2fd777d323b125a16bdc6d75227585e21253e
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62426990"
---
# <a name="c26431-donttestnotnull"></a>C26431 DONT_TEST_NOTNULL

"Typ wyrażenia jest już gsl::not_null. Nie Testuj go pod kątem."

**W języku C++ podstawowych wytycznych dotyczących**: F.23: Użyj not_null\<T > do wskazania, że "null" nie jest prawidłową wartością

Gsl::not_null typu znacznika z Guidelines Support Library umożliwia jasno wskazywać wartości, które nigdy nie są wskaźniki o wartości null. Jeśli takie założenia nie jest używana w czasie wykonywania, powoduje awarię twardych. Tak oczywiście, nie ma potrzeby do sprawdzenia pod kątem, jeśli wyrażenie ma wynik typ gsl::not_null.

## <a name="remarks"></a>Uwagi

- Ponieważ gsl::not_null samej klasy otoki wskaźnika alokowania elastycznego, reguła faktycznie śledzi zmiennych tymczasowych, które będą przechowywać wyniki wywołania do operatora konwersji przeciążona, (która zwraca obiekt zawartej wskaźnika). Takie logiki sprawia, że ta zasada dotyczy wyrażenia, które zawierają zmienne i mieć wynik o typie gsl::not_null. Jednak obecnie pomija wyrażeń zawierających wywołania funkcji, zwracając gsl::not_null.
  - Bieżący heurystyki do sprawdzania pod wykrywa następujących kontekstów się:
  - symbol wyrażenia w warunku gałęzi, np. "Jeśli (p) {...}";
  - operacje logiczne bitowy;
  - operacje porównania, w którym jeden z operandów jest wyrażeniem stałym, co jest ewaluowane jako zero.

## <a name="example"></a>Przykład

niepotrzebne sprawdzanie wartości null ujawnić wątpliwe logiki

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

niepotrzebne sprawdzanie wartości null ujawnić wątpliwe logic - przekształcił

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```
