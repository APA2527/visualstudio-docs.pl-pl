---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: cf144af63b95df9763b3906042f726c949202001
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/23/2019
ms.locfileid: "62560717"
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Przenoszenie, kopiowanie, ponowne przypisanie lub Resetuj lokalny wskaźnik inteligentny."

**W języku C++ podstawowych wytycznych dotyczących**: R.5: Preferuj obiekty w zakresie, nie przydzielaj niepotrzebnie w stercie

Inteligentne wskaźniki są dynamiczne zarządzanie zasobami wygodne, ale nie zawsze są niezbędne. Na przykład utworzenie lokalnych buforu dynamicznej można łatwo (czasem zakończenia więcej efektywnie) zarządza standardowych kontenerów. Dla pojedynczych obiektów nie jest konieczne w celu dynamicznego przydzielania (np. Jeśli takie obiekty nigdy nie on nakreślał ich funkcji twórcy) i mogą zostać zastąpione ze zmiennymi lokalnymi. Inteligentne wskaźniki stają się przydatne, gdy scenariusz wymaga zmiany własności, czyli ponowne przypisywanie zasobu dynamicznego wiele razy lub w wielu ścieżek. Obejmuje to także przypadkach, gdy zasoby są uzyskiwane z kodu zewnętrznego i inteligentne wskaźniki służą do rozszerzania okres istnienia zasobu.

## <a name="remarks"></a>Uwagi

- Oprócz standardowych std::unique_pointer i std::shared_pointer szablony to sprawdzenie rozpoznaje typy zdefiniowane przez użytkownika, które prawdopodobnie powinny być inteligentnych wskaźników. Typy takie oczekuje się zdefiniować następujące operacje:
  - przeciążone wyłuskania lub operatory dostępu do składowych, które są publiczne ale nie jest oznaczony jako usunięty;
  - destruktorem publicznym, który nie jest usuwane ani przyjmujące wartości domyślne. Dotyczy to również destruktory, które są jawnie definiowane pusty.
  - Typ Microsoft::WRL::ComPtr zachowuje się jak wspólny wskaźnik, ale jest często używana w bardzo konkretnych scenariuszy, które mają wpływ Zarządzanie okresem istnienia COM. Aby uniknąć nadmiernego hałasu tego typu jest odfiltrowana.
  - Ten test wyszukuje jawne alokacje lokalnym przypisane do inteligentnych wskaźników, aby ustalić, czy zmienne o zakresie można word jako alternatywa. Oprócz bezpośrednich wywołań do nowy operator specjalne funkcje, takie jak opcji std::make_unique i std::make_shared również są interpretowane jako bezpośrednie alokacji.

## <a name="example"></a>Przykład

dynamiczne buforu

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

dynamiczne buforu — zastępuje kontenera

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
