---
title: C26414
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 1115077aebf710d6902a273f48960dc6d7ad9392
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/02/2019
ms.locfileid: "53868355"
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
"Przenoszenie, kopiowanie, ponowne przypisanie lub Resetuj lokalny wskaźnik inteligentny."

**W języku C++ podstawowych wytycznych dotyczących**: R.5: Preferuj obiekty w zakresie, nie przydzielaj niepotrzebnie w stercie

Inteligentne wskaźniki są dynamiczne zarządzanie zasobami wygodne, ale nie zawsze są niezbędne. Na przykład utworzenie lokalnych buforu dynamicznej można łatwo (czasem zakończenia więcej efektywnie) zarządza standardowych kontenerów. Dla pojedynczych obiektów nie jest konieczne w celu dynamicznego przydzielania (np. Jeśli takie obiekty nigdy nie on nakreślał ich funkcji twórcy) i mogą zostać zastąpione ze zmiennymi lokalnymi. Inteligentne wskaźniki stają się przydatne, gdy scenariusz wymaga zmiany własności, czyli ponowne przypisywanie zasobu dynamicznego wiele razy lub w wielu ścieżek. Obejmuje to także przypadkach, gdy zasoby są uzyskiwane z kodu zewnętrznego i inteligentne wskaźniki służą do rozszerzania okres istnienia zasobu.

## <a name="remarks"></a>Uwagi
- Oprócz standardowych std::unique_pointer i std::shared_pointer szablony to sprawdzenie rozpoznaje typy zdefiniowane przez użytkownika, które prawdopodobnie powinny być inteligentnych wskaźników. Typy takie oczekuje się zdefiniować następujące operacje:
  - przeciążone wyłuskania lub operatory dostępu do składowych, które są publiczne ale nie jest oznaczony jako usunięty;
  - destruktorem publicznym, który nie jest usuwane ani przyjmujące wartości domyślne. Dotyczy to również destruktory, które są jawnie definiowane pusty.
  - Typ Microsoft::WRL::ComPtr zachowuje się jak wspólny wskaźnik, ale jest często używana w bardzo konkretnych scenariuszy, które mają wpływ Zarządzanie okresem istnienia COM. Aby uniknąć nadmiernego hałasu tego typu jest odfiltrowana.
  - <a name="this-check-looks-for-explicit-local-allocations-assigned-to-smart-pointers-to-identify-if-scoped-variables-could-word-as-an-alternative-in-addition-to-direct-calls-to-operator-new-special-functions-like-stdmakeunique-and-stdmakeshared-are-also-interpreted-as-direct-allocations"></a>Ten test wyszukuje jawne alokacje lokalnym przypisane do inteligentnych wskaźników, aby ustalić, czy zmienne o zakresie można word jako alternatywa. Oprócz bezpośrednich wywołań do nowy operator specjalne funkcje, takie jak opcji std::make_unique i std::make_shared również są interpretowane jako bezpośrednie alokacji.
    -
    ## <a name="example"></a>Przykład
    dynamiczne buforu

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Przykład
dynamiczne buforu — zastępuje kontenera

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
