---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011678"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Przenieś, skopiuj, ponownie Przypisz lub zresetuj lokalny wskaźnik inteligentny".

**C++ Podstawowe wytyczne**: R. 5: Preferuj obiekty w zakresie, nie należy niepotrzebnie przydzielać sterty

Inteligentne wskaźniki są wygodne do dynamicznego zarządzania zasobami, ale nie zawsze są konieczne. Tworzenie lokalnego buforu dynamicznego można na przykład łatwo (kończyć czasem bardziej wydajnym) zarządzanym przez standardowe kontenery. W przypadku pojedynczych obiektów może być konieczne przeprowadzenie dynamicznej alokacji w ogóle (np. Jeśli obiekty te nigdy nie są na bieżąco używane przez funkcję twórcy) i można je zastąpić zmiennymi lokalnymi. Inteligentne wskaźniki stają się przydatne, gdy scenariusz wymaga zmiany własności, czyli ponownego przypisania zasobu dynamicznego wiele razy lub w wielu ścieżkach. Obejmuje to również przypadki, w których zasoby są uzyskiwane z kodu zewnętrznego i inteligentne wskaźniki są używane do rozszerania okresu istnienia zasobu.

## <a name="remarks"></a>Uwagi

- Oprócz standardowych szablonów std:: unique_pointer i std:: shared_pointer, ten test rozpoznaje typy zdefiniowane przez użytkownika, które mogą być inteligentnymi wskaźnikami. Takie typy powinny definiować następujące operacje:
  - przeciążone operatory dostępu wywołujące lub składowe, które są publiczne i nie są oznaczone jako usunięte;
  - publiczny destruktor, który nie został usunięty ani nie jest domyślny. Obejmuje to destruktory, które są jawnie zdefiniowane jako puste.
  - Typ Microsoft:: WRL:: ComPtr zachowuje się jako wspólny wskaźnik, ale jest często używany w scenariuszach, w których wpływ ma zarządzanie okresem istnienia modelu COM. Aby uniknąć nadmiernego szumu, ten typ jest odfiltrowany.
  - To sprawdzenie szuka jawnych przydziałów lokalnych przypisanych do inteligentnych wskaźników, aby określić, czy zmienne w zakresie mogą wyrazić alternatywę. Oprócz bezpośrednich wywołań operatora new, funkcje specjalne, takie jak std:: make_unique i std:: make_shared, są również interpretowane jako alokacje bezpośrednie.

## <a name="example"></a>Przykład

bufor dynamiczny

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

bufor dynamiczny — zastąpiony przez kontener

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
