---
title: C6211
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 1b21728e2092bc37e001fe47d40dadf719124235
ms.sourcegitcommit: 21d667104199c2493accec20c2388cf674b195c3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/08/2019
ms.locfileid: "55907259"
---
# <a name="c6211"></a>C6211
Ostrzeżenie C6211: Przeciek pamięci \<wskaźnik > z powodu wyjątku. Należy wziąć pod uwagę przy użyciu lokalnego bloku catch do wyczyszczenia pamięci

 To ostrzeżenie wskazuje, że że przydzielonej pamięci jest nie zwalniane gdy wyjątek jest zgłaszany. Wykonywanie instrukcji na końcu ścieżki może zgłosić wyjątek. Analizator sprawdza ten dodatkowy warunek tylko wtedy, gdy `_Analysis_mode_(_Analysis_local_leak_checks_)` sal jest określony. Domyślnie ta adnotacja jest określona dla kodu (sterownika) trybu jądra Windows. Aby uzyskać więcej informacji na temat adnotacji SAL, zobacz [przy użyciu adnotacji SAL w celu zmniejszenia defektów kodu C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Przykład
 Poniższy kod generuje, to ostrzeżenie, ponieważ może się wyjątek podczas drugiego alokacji, a tym samym przeciek pierwszy alokacji lub może zostać zgłoszony wyjątek gdzieś w kodzie, który jest reprezentowany przez "`code ...`" komentarz i tym samym przecieki pamięci zarówno alokacji.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4 
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_) 
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}
```

 Aby użyć tej samej funkcji alokacji i rozwiązać ten problem, Dodaj program obsługi wyjątku:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_) 

void f()
{
    char *p1 = nullptr; 
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}
```

 Aby całkowicie uniknąć tego rodzaju potencjalnymi wyciekami, użyj mechanizmów, które są dostarczane przez C++ standardowy szablon biblioteki (STL). Obejmują one [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class), i [wektor](/cpp/standard-library/vector). Aby uzyskać więcej informacji, zobacz [inteligentne wskaźniki](/cpp/cpp/smart-pointers-modern-cpp) i [standardowej biblioteki języka C++](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_) 

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr 
    // clean up when out of scope.
}
```

## <a name="see-also"></a>Zobacz też
 [Obsługa wyjątków języka C++](/cpp/cpp/cpp-exception-handling)