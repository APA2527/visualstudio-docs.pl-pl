---
title: C6312
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6312
helpviewer_keywords:
- C6312
ms.assetid: 1fc8b9a1-e6ba-4799-84c3-31f289576cca
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 48f18934d1bf78a1764bd3ac7a7c8b7b64508ece
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2019
ms.locfileid: "72017758"
---
# <a name="c6312"></a>C6312
Ostrzeżenie C6312: Możliwa nieskończona pętla: Użycie stałej EXCEPTION_CONTINUE_EXECUTION w wyrażeniu filtru wyjątków try-except

 To ostrzeżenie wskazuje na użycie stałej `EXCEPTION_CONTINUE_EXECUTION` (lub innej stałej, która daje w wyniku-1) w wyrażeniu filtru programu obsługi wyjątków strukturalnych. Użycie stałej wartości `EXCEPTION_CONTINUE_EXECUTION` może prowadzić do nieskończonej pętli. Na przykład, jeśli wyjątek został zgłoszony przez sprzęt, instrukcja, która spowodowała wyjątek, zostanie uruchomiona ponownie. Jeśli adres, który spowodował wyjątek, jest nadal zły, inny wyjątek wystąpi i będzie obsługiwany w ten sam sposób. Powoduje to nieskończoną pętlę.

 Jawne wywołanie `RaiseException` nie spowoduje bezpośredniej pętli nieskończonej, ale będzie kontynuować wykonywanie kodu w bloku chronionym. Może to być nieoczekiwane i może prowadzić do nieskończonej pętli, jeśli użyto `RaiseException`, aby uniknąć odwołującego się do nieprawidłowego wskaźnika.

 Zwykle `EXCEPTION_CONTINUE_EXECUTION` powinna być zwracana tylko przez funkcję wywołana w wyrażeniu filtru, która ma szansę na rozwiązanie wskaźnika, który spowodował wyjątek lub pamięć źródłową.

## <a name="example"></a>Przykład
 Poniższy kod generuje to ostrzeżenie:

```
#include <excpt.h>
#include <stdio.h>
#include <windows.h>

void f (char *ptr)
{
  __try
  {
    // exception occurs if the caller passes null ptr
    // code...
   *ptr = '\0';
  }
  __except (EXCEPTION_CONTINUE_EXECUTION)
    // When EXCEPTION_CONTINUE_EXECUTION is used, the handler
    //  block of the structured exception handler is not executed.
  {
    puts("This block is never executed");
  }
}
```

 Aby poprawić to ostrzeżenie, należy użyć następującego kodu:

```
#include <excpt.h>
#include <stdio.h>
#include <windows.h>

void f (char *ptr)
{
  __try
  {
    // exception occurs if the caller passes null ptr
    // code...
    *ptr = '\0';
  }
  __except (GetExceptionCode()== EXCEPTION_ACCESS_VIOLATION ?
               EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
  {
    puts("Error Occurred");
  }
}
```