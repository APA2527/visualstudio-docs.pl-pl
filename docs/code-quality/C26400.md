---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016619"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

To sprawdzenie pomaga wymusić *rule I. 11: Nigdy nie przesyłaj własności przez nieprzetworzony wskaźnik (T @ no__t-0)* , który jest podzbiorem reguły *R. 3: Nieprzetworzony wskaźnik (T @ no__t-0) nie jest właścicielem.* W związku z tym ostrzega o wszelkich wywołaniach operatora `new`, co zapisuje wynik w zmiennej typu pierwotnego wskaźnika. Ostrzega również o wywołaniach funkcji, które zwracają `gsl::owner<T>`, jeśli ich wyniki są przypisane do nieprzetworzonych wskaźników. Dobrym pomysłem jest to, że należy jasno określać własność zasobów pamięci. Aby uzyskać więcej informacji, zobacz [ C++ podstawowe wskazówki](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Najprostszym sposobem na rozwiązanie tego jest użycie deklaracji `auto`, jeśli zasób jest przypisywany natychmiast w deklaracji zmiennej. Jeśli nie jest to możliwe, zalecamy użycie typu `gsl::owner<T>`. Deklaracje `auto` inicjowane z operatorem `new` są "właścicielami", ponieważ zakłada się, że wynik każdej alokacji jest niejawnie wskaźnikiem właściciela. Przeniesiemy to założenie do zmiennej `auto` i traktuje ją jako `owner<T>`.

Jeśli to sprawdzenie flaguje wywołanie funkcji, która zwraca `owner<T>`, może to wskazywać na wiarygodną usterkę w kodzie. Zasadniczo wskazuje miejsce, gdzie kod wycieka jawnego koncepcji własności (i może być samym zasobem).

## <a name="remarks"></a>Uwagi

Ta zasada sprawdza obecnie tylko zmienne lokalne. Jeśli alokacja jest przypisana do parametru formalnego, zmiennej globalnej, składowej klasy i tak dalej, nie jest oflagowana. Odpowiednie pokrycie takich scenariuszy jest częścią przyszłej pracy.

## <a name="example-1-simple-allocation"></a>Przykład 1: Prosta alokacja

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Przykład 2: Prosta alokacja (naprawiona przy użyciu GSL:: Owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
