---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 0b9d4dee5914d7281ccf9d19a46b87282a998f3a
ms.sourcegitcommit: 21d667104199c2493accec20c2388cf674b195c3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/08/2019
ms.locfileid: "55913564"
---
# <a name="c26400-norawpointerassignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT
To sprawdzenie ułatwia Wymuszanie *I.11 reguły: Własność nigdy nie są przesyłane przez surowy wskaźnik (T\*)*, która jest podzbiorem reguły *R.3: Surowy wskaźnik (typu T\*) jest inne niż będącej właścicielem.* W szczególności ostrzega użytkownika przy każdym wywołaniu operatora `new` który zapisuje wynik w zmiennej surowego wskaźnika typu. Zawiera ono również ostrzeżenie dla wywołań funkcji, które zwracają `gsl::owner<T>` jeśli ich wyniki są przypisane do surowych wskaźników. W tym miejscu chodzi o to, należy wyraźnie określają prawo własności zasobów pamięci. Aby uzyskać więcej informacji, zobacz [podstawowych wytycznych dotyczących języka C++](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Najprostszym sposobem, aby rozwiązać ten problem, jest użycie `auto` deklaracji, jeśli zasób jest przypisywany natychmiast w deklaracji zmiennej. Jeśli nie jest to możliwe, a następnie zalecamy użycie typu `gsl::owner<T>`. `auto` Deklaracje inicjowane za pomocą operatora `new` są "właściciele", ponieważ przyjęto założenie, że wynik każdej alokacji jest niejawnie wskaźnika właściciela. Możemy przenieść tej założeń do `auto` zmienna i jej traktowała jako `owner<T>`.

Jeżeli to sprawdzenie flagi wywołanie funkcji, która zwraca `owner<T>`, może to być wskazanie uzasadnione usterki w kodzie. Po prostu punktów w miejscu, gdzie kod przecieków jawne pojęcie własności (i być może zasób).

## <a name="remarks"></a>Uwagi
- Ta reguła obecnie (Visual Studio 2017, wersja 15.3) sprawdza tylko zmienne lokalne. Jeśli alokacja jest przypisany do formalnego parametru, zmienna globalna, składowej klasy i tak dalej, nie jest traktowane. Odpowiednie pokrycie takich scenariuszy jest częścią przyszłych zadań.

## <a name="example-1-simple-allocation"></a>Przykład 1: Proste alokacji
```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Przykład 2: Proste alokacji (Naprawiono gsl::owner<T>)
```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
